# Concise Import Alias Scheme

## Core Rules

### 1. Use Subdomain Names Directly

Import submodules using their subdomain name as the alias:

```rust
use crate::runtime::{eval, world};
use crate::syntax::parser;
use crate::validation::{grammar, semantic};
```

### 2. Import Core Types via Prelude

Import frequently used types via the core prelude:

```rust
use crate::prelude::*;
```

**Core Types in Prelude:**

- `AstNode` - Abstract syntax tree node type
- `Expr` - Expression type for AST nodes
- `Span` - Source code location tracking
- `Spanned` - Trait for types with source spans
- `Value` - Runtime value type (numbers, strings, lists, etc.)
- `World` - World state for execution context
- `SutraError` - Main error type for the language
- `ErrorType` - Error classification enum
- `AtomRegistry` - Registry for atom definitions and lookup
- `SharedOutput` - Shared output sink for I/O operations
- `MacroRegistry` - Registry for macro definitions and lookup
- `to_error_source` - Function to create error source contexts
- `MacroDefinition` - Core macro definition type used across domains
- `AtomExecutionContext` - Core execution context for atoms
- `EvaluationContext` - Core evaluation context for AST nodes
- `Path` - Canonical path representation for world state access
- `err_msg` - Error macro for simple message-only errors
- `err_ctx` - Error macro for context-based errors
- `err_src` - Error macro for source-based errors

### 3. Import Domain-Specific Types Directly

Import types that are used frequently in a domain:

```rust
use crate::atoms::{AtomRegistry, OutputSink};
use crate::macros::{MacroDefinition, MacroExpansionContext, MacroRegistry};
```

### 4. Use Qualified Paths for Functions

Always use the alias with qualified paths:

```rust
// ✅ Correct
let result = eval::evaluate(&ast, &mut world)?;
let parsed = parser::parse(source)?;

// ❌ Wrong - don't import functions directly
use crate::runtime::eval::evaluate;
let result = evaluate(&ast, &mut world)?;
```

### 5. Maintain Clear Origins

The alias should make the origin obvious:

```rust
// ✅ Clear origin
eval::evaluate()        // from runtime::eval
parser::parse()         // from syntax::parser
semantic::validate()    // from validation::semantic

// ❌ Unclear origin
evaluate()              // where does this come from?
```

## Complete Alias Mapping

| Module Path                   | Alias        | Usage Pattern                               |
| ----------------------------- | ------------ | ------------------------------------------- |
| `crate::runtime::eval`        | `eval`       | `eval::evaluate(...)`                       |
| `crate::runtime::world`       | `world`      | `world::build_canonical_macro_env()`        |
| `crate::syntax::parser`       | `parser`     | `parser::parse(...)`                        |
| `crate::validation::semantic` | `semantic`   | `semantic::validate_expanded_ast(...)`      |
| `crate::validation::grammar`  | `grammar`    | `grammar::validate_grammar(...)`            |
| `crate::atoms::helpers`       | `helpers`    | `helpers::validate_special_form_arity(...)` |
| `crate::atoms::test`          | `test`       | `test::register_test_atoms(...)`            |
| `crate::macros::expander`     | `expander`   | `expander::expand_macros_recursively(...)`  |
| `crate::macros::loader`       | `loader`     | `loader::load_macro_file(...)`              |
| `crate::macros::std_macros`   | `std_macros` | `std_macros::register_standard_macros(...)` |
| `crate::ast::value`           | `value`      | `value::Value`                              |
| `crate::discovery`            | `discovery`  | `discovery::discover_test_files(...)`       |

## File-Specific Patterns

### Engine Files (engine.rs, cli.rs)

```rust
// Core types via prelude
use crate::prelude::*;

// Domain modules with aliases
use crate::{
    atoms::{AtomRegistry, OutputSink},
    macros::{MacroDefinition, MacroExpansionContext, MacroRegistry, expand_macros_recursively, parse_macro_definition, MacroValidationContext},
    runtime::{eval, world},
    syntax::parser,
    validation::semantic,
};
```

### Atom Files (atoms/\*.rs)

```rust
// Core types via prelude
use crate::prelude::*;

// Domain modules with aliases
use crate::{
    runtime::eval,
    ast::{AstNode, Expr, Span, Spanned},
    atoms::helpers,
};
```

### Test Files (test/\*.rs)

```rust
// Core types via prelude
use crate::prelude::*;

// Domain modules with aliases
use crate::{
    runtime::eval,
    discovery,
};
```

### Validation Files (validation/\*.rs)

```rust
// Core types via prelude
use crate::prelude::*;

// Domain modules with aliases
use crate::{
    validation::semantic,
    ast::{AstNode, Expr, Span, Spanned},
};
```

## Benefits

1. **Maximum Conciseness** - `eval::evaluate()` vs `runtime::eval::evaluate()`
2. **Clear Origins** - Always obvious where functions come from
3. **No Collisions** - Each subdomain name is unique
4. **Consistent Pattern** - Same approach across all files
5. **Rust Idiomatic** - Uses standard `as` aliases

## Remember

- Always use qualified paths with aliases
- Never import functions directly when using aliases
- Use prelude for core types to avoid repetition
- Maintain the same pattern across all files
