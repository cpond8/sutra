// Sutra Engine - Unified PEG-based Parser
// =======================================
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/syntax/grammar.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.
//!
//! # Sutra Parser: Grammar-to-AST Mapping
//!
//! | PEG Rule      | AST Node         | Notes                         |
//! |---------------|------------------|-------------------------------|
//! | program       | Vec<Expr>        | Top-level expressions; see note below |
//! | expr          | Expr             | Delegates to subrules         |
//! | list          | Expr::List       | Regular list only             |
//! | dotted_list   | (REMOVED)        | (REMOVED)                     |
//! | block         | Expr::List       | Brace blocks                  |
//! | atom          | Expr             | Number, Bool, String, Symbol  |
//! | number        | Expr::Number     |                               |
//! | boolean       | Expr::Bool       |                               |
//! | string        | Expr::String     |                               |
//! | symbol        | Expr::Symbol     |                               |
//!
//! **Span conventions:**
//! - All AST nodes carry a span covering the full source range of the parsed form.
//! - For dotted lists, the dot is represented as `Expr::Symbol(".")` with the span of the entire dotted list (not just the dot token).
//! - This is intentional for simplicity and is documented for downstream consumers.
//!
//! **Program node representation:**
//! - The public `parse` API returns a `Vec<Expr>` for top-level forms.
//! - Internally, `build_program` returns an `Expr::List` for uniformity, but this is unwrapped by `parse`.
//! - If a canonical program node is ever needed, document and update accordingly.

use crate::ast::{Expr, Span, WithSpan};
use crate::syntax::error::{internal_parse_error, malformed_ast_error, parse_error, SutraError};
use once_cell::sync::Lazy;
use pest::error::InputLocation;
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;
use std::collections::HashMap;

// This derive macro generates the parser implementation from our grammar file.
#[derive(Parser)]
#[grammar = "syntax/grammar.pest"]
struct SutraParser;

/// Parses a source string into a vector of top-level Sutra `Expr` AST nodes.
///
/// This function is the sole public entry point to the parser. It is purely
/// syntactic and does not add any semantic wrappers like `(do ...)`.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Vec<Expr>)` - A vector of expressions found at the top level of the source.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source: &str) -> Result<Vec<WithSpan<Expr>>, SutraError> {
    // `SutraParser::parse` attempts to match the `program` rule from the grammar.
    // If it fails, it returns a `pest` error, which we map to our `SutraError`.
    let pairs = SutraParser::parse(Rule::program, source).map_err(|e| {
        let span = match e.location {
            InputLocation::Pos(pos) => Span {
                start: pos,
                end: pos,
            },
            InputLocation::Span((start, end)) => Span { start, end },
        };
        parse_error(e.to_string(), Some(span))
    })?;

    // The `program` rule is guaranteed to have one inner pair (itself) if parsing succeeds.
    let root_pair = pairs.peek().ok_or_else(|| {
        parse_error(
            "Parser generated an empty tree, this should not happen.",
            None,
        )
    })?;

    // We build the AST from all expressions found inside the `program` rule.
    root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect()
}

// Utility function for consistent span extraction
fn get_span(pair: &pest::iterators::Pair<Rule>) -> Span {
    Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    }
}

// Type alias for AST builder functions
pub type AstBuilderFn = fn(Pair<Rule>) -> Result<WithSpan<Expr>, SutraError>;

// Static map from Rule to handler function
pub static AST_BUILDERS: Lazy<HashMap<Rule, AstBuilderFn>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert(Rule::program, build_program as AstBuilderFn);
    m.insert(Rule::expr, build_expr as AstBuilderFn);
    m.insert(Rule::list, build_list as AstBuilderFn);
    m.insert(Rule::param_list, build_param_list as AstBuilderFn);
    m.insert(Rule::block, build_block as AstBuilderFn);
    m.insert(Rule::number, build_number as AstBuilderFn);
    m.insert(Rule::boolean, build_boolean as AstBuilderFn);
    m.insert(Rule::string, build_string as AstBuilderFn);
    m.insert(Rule::symbol, build_symbol as AstBuilderFn);
    m.insert(Rule::quote, build_quote as AstBuilderFn);
    m.insert(Rule::define_form, build_define_form as AstBuilderFn);
    m.insert(Rule::atom, build_atom as AstBuilderFn);
    m
});

// Dispatcher: looks up the handler in the map and calls it
fn build_ast_from_pair(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    AST_BUILDERS.get(&pair.as_rule()).ok_or_else(|| {
        internal_parse_error(
            format!(
                "No AST builder registered for rule: {:?} (input: '{}')",
                pair.as_rule(),
                pair.as_str()
            ),
            Some(get_span(&pair)),
        )
    })?(pair)
}

// Private combinator for mapping children to Expr::List
fn map_children_to_list<'a>(
    children: Box<dyn Iterator<Item = Pair<Rule>> + 'a>,
    builder: AstBuilderFn,
    span: Span,
) -> Result<WithSpan<Expr>, SutraError> {
    let exprs = children.map(builder).collect::<Result<Vec<_>, _>>()?;
    Ok(WithSpan {
        value: Expr::List(exprs, span.clone()),
        span,
    })
}

/// Handles the top-level program rule.
///
/// Note: Returns an `Expr::List` for internal uniformity, but the public `parse` API collects top-level forms as a `Vec<Expr>`.
/// If a canonical program node is ever needed, update this convention and document accordingly.
fn build_program(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    map_children_to_list(
        Box::new(
            pair.clone()
                .into_inner()
                .filter(|p| p.as_rule() != Rule::EOI),
        ),
        build_ast_from_pair,
        span,
    )
}

/// Handles expr rule (delegates to subrules).
fn build_expr(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| {
        malformed_ast_error(
            format!("Empty expr pair (input: '{}')", pair.as_str()),
            Some(span),
        )
    })?;
    build_ast_from_pair(sub)
}

/// Handles list rule (proper lists only).
fn build_list(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    map_children_to_list(
        Box::new(pair.clone().into_inner()),
        build_ast_from_pair,
        span,
    )
}

/// Enum representing the partitioned parameter list: either only required parameters, or required plus a single rest parameter.
#[derive(Debug)]
enum ParamListParts<'a> {
    RequiredOnly(Vec<&'a Pair<'a, Rule>>),
    RequiredAndRest(Vec<&'a Pair<'a, Rule>>, &'a Pair<'a, Rule>),
}

/// Parses a parameter list into an Expr::ParamList using a maximally functional, type-driven approach.
///
/// # Invariants
/// - All required parameters (symbols) must come before any rest parameter ("... rest").
/// - Only one rest parameter is allowed, and it must be the last.
/// - Any violation results in a precise error.
///
/// # Errors
/// - Required parameter after rest: error.
/// - Multiple rest parameters: error.
/// - Non-symbol after ...: error.
/// - Invalid parameter type: error.
///
/// # Example
/// ```ignore
/// let pair = SutraParser::parse(Rule::param_list, "x y ...rest").unwrap().next().unwrap();
/// let result = build_param_list(pair).unwrap();
/// assert!(matches!(result.value, Expr::ParamList(_)));
/// ```
fn build_param_list(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let pairs: Vec<_> = pair.clone().into_inner().collect();
    let parts = partition_param_list(&pairs, &span)?;
    let (required, rest) = match parts {
        ParamListParts::RequiredOnly(req) => (req, None),
        ParamListParts::RequiredAndRest(req, rest) => (req, Some(rest)),
    };
    let required_syms = required
        .into_iter()
        .map(as_symbol)
        .collect::<Result<Vec<_>, _>>()?;
    let rest_sym = rest.map(as_symbol).transpose()?;
    Ok(WithSpan {
        value: Expr::ParamList(crate::ast::ParamList {
            required: required_syms,
            rest: rest_sym,
            span: span.clone(),
        }),
        span,
    })
}

/// Partitions the parameter list into required and rest parameters using iterator combinators and type-driven invariants.
/// Returns a ParamListParts enum, making illegal states unrepresentable.
fn partition_param_list<'a>(
    pairs: &'a [Pair<Rule>],
    span: &Span,
) -> Result<ParamListParts<'a>, SutraError> {
    match pairs.iter().position(|p| p.as_str() == "...") {
        Some(idx) => {
            // "..." must be followed by a symbol and be the last two elements
            if idx + 2 != pairs.len() {
                return Err(parse_error(
                    "Required parameter after ...rest in parameter list",
                    Some(span.clone()),
                ));
            }
            let rest_pair = pairs.get(idx + 1).ok_or_else(|| {
                parse_error(
                    "Expected symbol after ... in parameter list",
                    Some(span.clone()),
                )
            })?;
            if rest_pair.as_rule() != Rule::symbol {
                return Err(parse_error(
                    "Expected symbol after ... in parameter list",
                    Some(span.clone()),
                ));
            }
            Ok(ParamListParts::RequiredAndRest(
                pairs[..idx].iter().collect(),
                rest_pair,
            ))
        }
        None => Ok(ParamListParts::RequiredOnly(pairs.iter().collect())),
    }
}

/// Converts a Pair<Rule> to a symbol string, erroring if not a symbol.
fn as_symbol(pair: &Pair<Rule>) -> Result<String, SutraError> {
    let span = get_span(pair);
    match build_symbol(pair.clone())? {
        WithSpan {
            value: Expr::Symbol(s, _),
            ..
        } => Ok(s),
        _ => Err(parse_error("Expected symbol in parameter list", Some(span))),
    }
}

/// Handles block rule (brace blocks).
fn build_block(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    map_children_to_list(
        Box::new(pair.clone().into_inner()),
        build_ast_from_pair,
        span,
    )
}

/// Handles atom rule (delegates to subrules).
fn build_atom(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| {
        malformed_ast_error(
            format!("Empty atom pair (input: '{}')", pair.as_str()),
            Some(span),
        )
    })?;
    build_ast_from_pair(sub)
}

/// Handles number rule.
fn build_number(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let s = pair.as_str();
    let n = s.parse().map_err(|e| {
        parse_error(
            format!(
                "number: Invalid number: expected numeric literal, found '{}', error: {}",
                s, e
            ),
            Some(span.clone()),
        )
    })?;
    Ok(WithSpan {
        value: Expr::Number(n, span.clone()),
        span,
    })
}

/// Handles boolean rule.
fn build_boolean(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let s = pair.as_str();
    match s {
        "true" => Ok(WithSpan {
            value: Expr::Bool(true, span.clone()),
            span,
        }),
        "false" => Ok(WithSpan {
            value: Expr::Bool(false, span.clone()),
            span,
        }),
        _ => Err(parse_error(
            format!(
                "boolean: Invalid boolean: expected 'true' or 'false', found '{}'",
                s
            ),
            Some(span),
        )),
    }
}

/// Handles string rule.
fn build_string(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    Ok(WithSpan {
        value: Expr::String(unescape_string(pair.clone())?, span.clone()),
        span,
    })
}

/// Handles symbol rule.
fn build_symbol(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    Ok(WithSpan {
        value: Expr::Symbol(pair.as_str().to_string(), span.clone()),
        span,
    })
}

/// Pure helper function to unescape a string from a `pest` `Pair`.
///
/// Note: Only supports basic escapes (\n, \t, \\, \"). Unicode (\uXXXX) and hex/octal escapes are NOT supported.
/// This is sufficient for current narrative scripting, but should be extended if such escapes are needed in the future.
fn unescape_string(pair: Pair<Rule>) -> Result<String, SutraError> {
    // The `string` rule in the grammar is `@{ "\"" ~ inner ~ "\"" }`.
    // `pair.as_str()` gives us the full text, including the surrounding quotes.
    let full_str = pair.as_str();

    // We slice the string to remove the first and last characters (the quotes).
    // This is simpler and more robust than traversing the CST, even if it's
    // slightly less performant for very long strings. The correctness and
    // simplicity trade-off is worth it here.
    let inner_str = &full_str[1..full_str.len() - 1];

    // Now, we manually unescape the recognized sequences.
    let mut result = String::with_capacity(inner_str.len());
    let mut chars = inner_str.chars();
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('t') => result.push('\t'),
                Some('\\') => result.push('\\'),
                Some('"') => result.push('"'),
                // If we encounter an invalid escape, we just push the characters
                // literally. The grammar should prevent this, but this is safer.
                Some(other) => {
                    result.push('\\');
                    result.push(other);
                }
                // A dangling escape at the end of a string.
                None => result.push('\\'),
            }
        } else {
            result.push(c);
        }
    }
    Ok(result)
}

/// Canonical CST node for the parsing pipeline (modular, interface-driven).
#[derive(Debug, Clone, PartialEq)]
pub struct SutraCstNode {
    pub rule: String, // Use String for rule name for now; can be enum if desired
    pub children: Vec<SutraCstNode>,
    pub span: crate::ast::Span,
    // Optionally: text, parent, etc.
}

#[derive(Debug, Clone, PartialEq)]
pub enum SutraCstParseError {
    Syntax {
        span: crate::ast::Span,
        message: String,
    },
    Incomplete {
        span: crate::ast::Span,
        message: String,
    },
    // ...
}

/// Canonical trait for a CST parser (modular pipeline contract).
pub trait SutraCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError>;
    fn traverse<'a>(&'a self, node: &'a SutraCstNode) -> SutraCstTraversal<'a>;
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(
        &'a self,
        node: &'a SutraCstNode,
        visitor: F,
        order: TraversalOrder,
    );
}

/// Iterator for CST traversal (DFS/BFS).
pub struct SutraCstTraversal<'a> {
    // Implementation details omitted for now
    _phantom: std::marker::PhantomData<&'a SutraCstNode>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TraversalOrder {
    DepthFirst,
    BreadthFirst,
}

/// Trivial CST parser for pipeline scaffolding (Sprint 2).
pub struct TrivialCstParser;

impl SutraCstParser for TrivialCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError> {
        Ok(SutraCstNode {
            rule: "Program".to_string(),
            children: vec![],
            span: crate::ast::Span {
                start: 0,
                end: input.len(),
            },
        })
    }
    fn traverse<'a>(&'a self, _node: &'a SutraCstNode) -> SutraCstTraversal<'a> {
        SutraCstTraversal {
            _phantom: std::marker::PhantomData,
        }
    }
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(
        &'a self,
        _node: &'a SutraCstNode,
        _visitor: F,
        _order: TraversalOrder,
    ) {
        // No-op for trivial impl
    }
}

/// Real CST parser using pest and the canonical grammar.
pub struct PestCstParser;

impl SutraCstParser for PestCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError> {
        let pairs = SutraParser::parse(Rule::program, input).map_err(|e| {
            let span = match e.location {
                InputLocation::Pos(pos) => crate::ast::Span {
                    start: pos,
                    end: pos,
                },
                InputLocation::Span((start, end)) => crate::ast::Span { start, end },
            };
            SutraCstParseError::Syntax {
                span,
                message: e.to_string(),
            }
        })?;
        let root_pair = pairs.peek().ok_or_else(|| SutraCstParseError::Incomplete {
            span: crate::ast::Span {
                start: 0,
                end: input.len(),
            },
            message: "Parser generated an empty tree, this should not happen.".to_string(),
        })?;
        Ok(build_cst_from_pair(root_pair))
    }
    fn traverse<'a>(&'a self, _node: &'a SutraCstNode) -> SutraCstTraversal<'a> {
        SutraCstTraversal {
            _phantom: std::marker::PhantomData,
        }
    }
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(
        &'a self,
        _node: &'a SutraCstNode,
        _visitor: F,
        _order: TraversalOrder,
    ) {
        // Not implemented for now
    }
}

fn build_cst_from_pair(pair: Pair<Rule>) -> SutraCstNode {
    let span = crate::ast::Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    };
    let rule = format!("{:?}", pair.as_rule());
    let children: Vec<SutraCstNode> = pair.clone().into_inner().map(build_cst_from_pair).collect();
    SutraCstNode {
        rule,
        children,
        span,
    }
}

#[cfg(test)]
mod pest_cst_tests {
    use super::*;
    #[test]
    fn pest_cst_parser_parses_simple_program() {
        let parser = PestCstParser;
        let input = "(foo 42)";
        let cst = parser.parse(input).unwrap();
        assert_eq!(cst.rule, "program");
        assert_eq!(cst.children.len(), 2); // expr + EOI
        let expr = &cst.children[0];
        assert_eq!(expr.rule, "expr");
        assert_eq!(expr.children.len(), 1);
        let list = &expr.children[0];
        assert_eq!(list.rule, "list");
        assert_eq!(list.span.start, 0);
        assert_eq!(list.span.end, 8);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn trivial_cst_parser_returns_minimal_node() {
        let parser = TrivialCstParser;
        let cst = parser.parse("(foo bar)").unwrap();
        assert_eq!(cst.rule, "Program");
        assert_eq!(cst.children.len(), 0);
        assert_eq!(cst.span.start, 0);
        assert_eq!(cst.span.end, 9);
    }
}

// Add missing handler for quote
fn build_quote(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.into_inner();
    let quoted = inner.next().ok_or_else(|| {
        malformed_ast_error(
            "quote: Empty quote pair (expected expr)".to_string(),
            Some(span.clone()),
        )
    })?;
    let quoted_expr = build_ast_from_pair(quoted)?;
    Ok(WithSpan {
        value: Expr::Quote(Box::new(quoted_expr), span.clone()),
        span,
    })
}

// Add missing handler for define_form
fn build_define_form(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();
    // Expect: param_list, expr (the literal "define" is consumed by the grammar)
    let param_list_pair = inner.next().ok_or_else(|| {
        malformed_ast_error(
            "define_form: Missing param_list in define_form (expected param_list)".to_string(),
            Some(span.clone()),
        )
    })?;
    let param_list_expr = build_ast_from_pair(param_list_pair)?;
    let body_pair = inner.next().ok_or_else(|| {
        malformed_ast_error(
            "define_form: Missing body expr in define_form (expected expr)".to_string(),
            Some(span.clone()),
        )
    })?;
    let body_expr = build_ast_from_pair(body_pair)?;
    Ok(WithSpan {
        value: Expr::List(
            vec![
                WithSpan {
                    value: Expr::Symbol("define".to_string(), span.clone()),
                    span: span.clone(),
                },
                param_list_expr,
                body_expr,
            ],
            span.clone(),
        ),
        span,
    })
}
