// Sutra Engine - Unified PEG-based Parser
// =======================================
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/sutra.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.

use crate::ast::{Expr, Span};
use crate::error::{SutraError, SutraErrorKind};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;

// This derive macro generates the parser implementation from our grammar file.
#[derive(Parser)]
#[grammar = "sutra.pest"]
struct SutraParser;

/// Parses a source string into a vector of top-level Sutra `Expr` AST nodes.
///
/// This function is the sole public entry point to the parser. It is purely
/// syntactic and does not add any semantic wrappers like `(do ...)`.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Vec<Expr>)` - A vector of expressions found at the top level of the source.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source: &str) -> Result<Vec<Expr>, SutraError> {
    // `SutraParser::parse` attempts to match the `program` rule from the grammar.
    // If it fails, it returns a `pest` error, which we map to our `SutraError`.
    let pairs = SutraParser::parse(Rule::program, source).map_err(|e| {
        // TODO: A future improvement would be to use a library like `pest_consume`
        // or write a more detailed error formatter to give even more user-friendly
        // error messages than the default `pest` provides.
        let span = match e.location {
            pest::error::InputLocation::Pos(pos) => Span {
                start: pos,
                end: pos,
            },
            pest::error::InputLocation::Span((start, end)) => Span { start, end },
        };
        SutraError {
            kind: SutraErrorKind::Parse(e.to_string()),
            span: Some(span),
        }
    })?;

    // The `program` rule is guaranteed to have one inner pair (itself) if parsing succeeds.
    let root_pair = pairs.peek().ok_or_else(|| SutraError {
        kind: SutraErrorKind::Parse(
            "Parser generated an empty tree, this should not happen.".to_string(),
        ),
        span: None,
    })?;

    // We build the AST from all expressions found inside the `program` rule.
    root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect()
}

/// Recursively builds an `Expr` AST from a `pest` `Pair`.
fn build_ast_from_pair(pair: Pair<Rule>) -> Result<Expr, SutraError> {
    let span = Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    };

    match pair.as_rule() {
        Rule::list | Rule::block => Ok(Expr::List(
            pair.into_inner()
                .map(build_ast_from_pair)
                .collect::<Result<Vec<_>, _>>()?,
            span,
        )),
        Rule::expr | Rule::atom => build_ast_from_pair(pair.into_inner().next().unwrap()),
        Rule::number => Ok(Expr::Number(pair.as_str().parse().unwrap(), span)),
        Rule::boolean => Ok(Expr::Bool(pair.as_str() == "true", span)),
        Rule::symbol => Ok(Expr::Symbol(pair.as_str().to_string(), span)),
        Rule::string => Ok(Expr::String(unescape_string(pair)?, span)),
        _ => unreachable!("Structural rules should not be processed here."),
    }
}

/// Pure helper function to unescape a string from a `pest` `Pair`.
fn unescape_string(pair: Pair<Rule>) -> Result<String, SutraError> {
    // The `string` rule in the grammar is `@{ "\"" ~ inner ~ "\"" }`.
    // `pair.as_str()` gives us the full text, including the surrounding quotes.
    let full_str = pair.as_str();

    // We slice the string to remove the first and last characters (the quotes).
    // This is simpler and more robust than traversing the CST, even if it's
    // slightly less performant for very long strings. The correctness and
    // simplicity trade-off is worth it here.
    let inner_str = &full_str[1..full_str.len() - 1];

    // Now, we manually unescape the recognized sequences.
    let mut result = String::with_capacity(inner_str.len());
    let mut chars = inner_str.chars();
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('t') => result.push('\t'),
                Some('\\') => result.push('\\'),
                Some('"') => result.push('"'),
                // If we encounter an invalid escape, we just push the characters
                // literally. The grammar should prevent this, but this is safer.
                Some(other) => {
                    result.push('\\');
                    result.push(other);
                }
                // A dangling escape at the end of a string.
                None => result.push('\\'),
            }
        } else {
            result.push(c);
        }
    }
    Ok(result)
}
