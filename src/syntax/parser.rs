// # Sutra Parser: Grammar-to-AST Mapping
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/syntax/grammar.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.
//
// Architecture:
// - **Public API**: `parse()` and `wrap_in_do()` are the only public functions
// - **Grammar Rules**: Each grammar rule has a corresponding builder function
// - **AST Builders**: Functions that construct specific AST node types
// - **Utilities**: Common patterns and helper functions
// - **Error Handling**: Centralized error message improvement
//
// Grammar Rule â†’ AST Node Mapping:
// | Grammar Rule    | Builder Function     | AST Node Type       | Notes                                 |
// |-----------------|----------------------|---------------------|---------------------------------------|
// | program         | build_program_ast    | Vec<AstNode>        | Top-level expressions                 |
// | expr            | build_expression_ast | AstNode             | Delegates to subrules                 |
// | list            | build_list_ast       | Expr::List          | Regular lists                         |
// | block           | build_list_ast       | Expr::List          | Brace-style blocks                    |
// | param_list      | build_param_list_ast | Expr::ParamList     | Function parameters                   |
// | atom            | build_atom_ast       | AstNode             | Delegates to subrules                 |
// | number          | build_number_ast     | Expr::Number        | Numeric literals                      |
// | boolean         | build_boolean_ast    | Expr::Bool          | Boolean literals                      |
// | string          | build_string_ast     | Expr::String        | String literals                       |
// | symbol          | build_symbol_ast     | Expr::Symbol/Path   | Symbols or paths                      |
// | quote           | build_quote_ast      | Expr::Quote         | Quoted expressions                    |
// | define_form     | build_define_form_ast| Expr::List          | List headed by `define` symbol        |
// | lambda_form     | build_lambda_form_ast| Expr::List          | Lambda expressions                    |
// | spread_arg      | build_spread_arg_ast | Expr::Spread        | Rest parameters                       |
// | list_elem       | build_expression_ast | AstNode             | Delegates to expression               |
//

use crate::{ast::ParamList, errors, prelude::*, runtime::source};
use miette::SourceSpan;
use pest::{
    error::{Error, InputLocation},
    iterators::Pair,
    Parser,
};
use pest_derive::Parser;
// ============================================================================
// STRUCTS
// ============================================================================

/// Holds the state of the parser.
///
/// This struct contains all the contextual information needed for parsing,
/// including the source code, and provides a unified object to pass down the
/// call stack. This simplifies function signatures and centralizes access to
/// parsing state.
struct ParserState {
    /// The source context, containing the source code and its identifier.
    pub source: source::SourceContext,
}

// ============================================================================
// MACROS
// ============================================================================

/// Creates a spanned expression with the given value and span
macro_rules! spanned_expr {
    ($expr:expr, $span:expr) => {
        Spanned {
            value: $expr.into(),
            span: $span,
        }
    };
}

// ============================================================================
// TYPE ALIASES
// ============================================================================

/// Type alias for top-level program parsing results
type ProgramParseResult = Result<Vec<AstNode>, SutraError>;

/// Type alias for individual expression parsing results
type ExpressionParseResult = Result<AstNode, SutraError>;

/// Type alias for symbol parsing results
type SymbolParseResult = Result<String, SutraError>;

// ============================================================================
// CONSTANTS
// ============================================================================

// Symbol constants
const DO_SYMBOL: &str = "do";
const LAMBDA_SYMBOL: &str = "lambda";

// Span constants
const EMPTY_SPAN: Span = Span { start: 0, end: 0 };

// Error pattern constants
const EXPECTED_CLOSING_PAREN: &str = "expected ')'";
const EXPECTED_CLOSING_BRACE: &str = "expected '}'";
const EXPECTED_BLOCK: &str = "expected block";
const EXPECTED_STRING: &str = "expected string";
const EXPECTED_QUOTE: &str = "expected '\"'";

// ============================================================================
// PEST PARSER DEFINITION
// ============================================================================

/// Pest-generated parser for the Sutra grammar
#[derive(Parser)]
#[grammar = "syntax/grammar.pest"]
struct SutraParser;

// ============================================================================
// PUBLIC API
// ============================================================================

/// Parses a source string into a vector of top-level Sutra `Expr` AST nodes.
///
/// This function is the sole public entry point to the parser. It is purely
/// syntactic and does not add any semantic wrappers like `(do ...)`.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Vec<Expr>)` - A vector of expressions found at the top level of the source.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source_text: &str, source_context: source::SourceContext) -> ProgramParseResult {
    // Handle empty or whitespace-only input gracefully
    if source_text.trim().is_empty() {
        return Ok(vec![]);
    }

    let mut state = ParserState {
        source: source_context,
    };

    // Parse using the grammar's program rule
    let pairs = SutraParser::parse(Rule::program, source_text)
        .map_err(|e| create_parse_error(e, &mut state))?;

    // Extract the root program node
    let root_pair = pairs.peek().ok_or_else(|| {
        errors::parse_empty(
            &state.source,
            SourceSpan::new(0.into(), source_text.len().into()),
        )
    })?;

    // Build AST from all expressions in the program
    root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(|p| build_ast_from_rule(p, &mut state))
        .collect()
}

/// Utility: Wraps a list of AST nodes in a (do ...) form if needed.
pub fn wrap_in_do(ast_nodes: Vec<AstNode>) -> AstNode {
    match ast_nodes.len() {
        0 => create_empty_list(),
        1 => ast_nodes
            .into_iter()
            .next()
            .expect("wrap_in_do: single node"),
        _ => create_do_block(ast_nodes),
    }
}

// ============================================================================
// GRAMMAR RULE BUILDERS
// ============================================================================

/// Main dispatcher that routes grammar rules to their corresponding AST builders
fn build_ast_from_rule(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    match pair.as_rule() {
        // Top-level structure
        Rule::program => build_program_ast(pair, state),
        Rule::expr => build_expression_ast(pair, state),

        // Container structures
        Rule::list => build_list_ast(pair, state),
        Rule::block => build_list_ast(pair, state), // Blocks are lists
        Rule::param_list => build_param_list_ast(pair, state),

        // Atomic values
        Rule::atom => build_atom_ast(pair, state),
        Rule::number => build_number_ast(pair, state),
        Rule::boolean => build_boolean_ast(pair, state),
        Rule::string => build_string_ast(pair),
        Rule::symbol => build_symbol_ast(pair, state),

        // Special forms
        Rule::quote => build_quote_ast(pair, state),
        Rule::lambda_form => build_lambda_form_ast(pair, state),
        Rule::define_form => build_define_form_ast(pair, state),
        Rule::spread_arg => build_spread_arg_ast(pair, state),

        rule => Err(errors::parse_malformed(
            format!("unsupported rule: {rule:?}"),
            &state.source,
            to_source_span(get_span(&pair)),
        )
        .with_suggestion("This syntax is not supported")),
    }
}

// ============================================================================
// TOP-LEVEL STRUCTURE BUILDERS
// ============================================================================

/// Builds AST for the top-level program rule
fn build_program_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);
    build_list_from_children(
        pair.into_inner()
            .filter(|p| p.as_rule() != Rule::EOI)
            .collect(),
        span,
        state,
    )
}

/// Builds AST for individual expressions (delegates to subrules)
fn build_expression_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let mut inner_pairs = pair.clone().into_inner();
    let sub_expression = inner_pairs
        .next()
        .ok_or_else(|| errors::parse_empty(&state.source, to_source_span(get_span(&pair))))?;
    build_ast_from_rule(sub_expression, state)
}

// ============================================================================
// CONTAINER STRUCTURE BUILDERS
// ============================================================================

/// Builds AST for list and block structures
fn build_list_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);

    build_list_from_children(pair.into_inner().collect(), span, state)
}

/// Builds AST for parameter lists with validation
fn build_param_list_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);

    let param_items_container = pair
        .into_inner()
        .next()
        .ok_or_else(|| {
            errors::parse_missing("parameter list", &state.source, to_source_span(span))
        })?
        .into_inner()
        .collect::<Vec<_>>();

    let mut required_params = Vec::new();
    let mut rest_param = None;
    let mut found_rest = false;

    for param_item in param_items_container {
        let (param_name, is_rest) = validate_and_extract_parameter(&param_item, found_rest, state)?;
        if is_rest {
            found_rest = true;
            rest_param = Some(param_name);
        } else {
            required_params.push(param_name);
        }
    }

    Ok(spanned_expr!(
        Expr::ParamList(ParamList {
            required: required_params,
            rest: rest_param,
            span
        }),
        span
    ))
}

// ============================================================================
// ATOMIC VALUE BUILDERS
// ============================================================================

/// Builds AST for atom rule (delegates to subrules)
fn build_atom_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let pair_span = get_span(&pair);
    let inner_expression = pair
        .clone()
        .into_inner()
        .next()
        .ok_or_else(|| errors::parse_empty(&state.source, to_source_span(pair_span)))?;
    build_ast_from_rule(inner_expression, state)
}

/// Builds AST for numeric literals
fn build_number_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);
    let number_text = pair.as_str();
    let number_value = number_text.parse::<f64>().map_err(|e| {
        errors::parse_invalid_value("number", e.to_string(), &state.source, to_source_span(span))
            .with_suggestion("Use valid decimal notation")
    })?;
    Ok(spanned_expr!(Expr::Number(number_value, span), span))
}

/// Builds AST for boolean literals
fn build_boolean_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);
    let boolean_text = pair.as_str();
    match boolean_text {
        "true" => Ok(spanned_expr!(Expr::Bool(true, span), span)),
        "false" => Ok(spanned_expr!(Expr::Bool(false, span), span)),
        _ => Err(errors::parse_invalid_value(
            "boolean",
            boolean_text,
            &state.source,
            to_source_span(span),
        )
        .with_suggestion("Use 'true' or 'false'")),
    }
}

/// Builds AST for string literals
fn build_string_ast(pair: Pair<Rule>) -> ExpressionParseResult {
    let span = get_span(&pair);
    Ok(spanned_expr!(
        Expr::String(unescape_string(pair.clone())?, span),
        span
    ))
}

/// Builds AST for symbols and paths
fn build_symbol_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);
    let symbol_text = pair.as_str();

    if symbol_text.contains('.') {
        validate_and_build_path(symbol_text, span, state)
    } else {
        Ok(spanned_expr!(
            Expr::Symbol(symbol_text.to_string(), span),
            span
        ))
    }
}

// ============================================================================
// SPECIAL FORM BUILDERS
// ============================================================================

/// Builds AST for quoted expressions
fn build_quote_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);
    let quoted_expression = build_ast_from_rule(
        pair.clone().into_inner().next().ok_or_else(|| {
            errors::parse_malformed("quote", &state.source, to_source_span(span))
                .with_suggestion("Quote requires an expression: '(expression)")
        })?,
        state,
    )?;
    Ok(spanned_expr!(
        Expr::Quote(Box::new(quoted_expression), span),
        span
    ))
}

/// Builds AST for lambda forms: (lambda (params...) body)
fn build_lambda_form_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    extract_form_parts(pair, state).map(|(param_list, body, span)| {
        let lambda_symbol_expr = Expr::Symbol(LAMBDA_SYMBOL.to_string(), span);
        let lambda_symbol_node = spanned_expr!(lambda_symbol_expr, span);
        let list_items = vec![lambda_symbol_node, param_list, body];
        let list_expr = Expr::List(list_items, span);
        spanned_expr!(list_expr, span)
    })
}

/// Builds AST for define forms: (define (name params...) body)
fn build_define_form_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    extract_form_parts(pair, state).map(|(param_list, body, span)| {
        let define_symbol_expr = Expr::Symbol("define".to_string(), span);
        let define_symbol_node = spanned_expr!(define_symbol_expr, span);
        let list_items = vec![define_symbol_node, param_list, body];
        let list_expr = Expr::List(list_items, span);
        spanned_expr!(list_expr, span)
    })
}

/// Builds AST for spread arguments: ...symbol
fn build_spread_arg_ast(pair: Pair<Rule>, state: &mut ParserState) -> ExpressionParseResult {
    let span = get_span(&pair);
    let spread_symbol_node = build_symbol_ast(
        pair.clone().into_inner().next().ok_or_else(|| {
            errors::parse_malformed("spread", &state.source, to_source_span(span))
                .with_suggestion("Use ...symbol for spread syntax")
        })?,
        state,
    )?;
    Ok(spanned_expr!(
        Expr::Spread(Box::new(spread_symbol_node)),
        span
    ))
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/// Extracts span from a pest pair
fn get_span(pair: &Pair<Rule>) -> Span {
    Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    }
}

/// Converts pest location to our span format
fn pest_location_to_span(location: InputLocation) -> Span {
    match location {
        InputLocation::Pos(pos) => Span {
            start: pos,
            end: pos,
        },
        InputLocation::Span((start, end)) => Span { start, end },
    }
}

/// Calculates span encompassing all AST nodes in a slice
fn calculate_span(ast_nodes: &[AstNode]) -> Span {
    Span {
        start: ast_nodes
            .first()
            .map(|n| n.span.start)
            .unwrap_or(EMPTY_SPAN.start),
        end: ast_nodes
            .last()
            .map(|n| n.span.end)
            .unwrap_or(EMPTY_SPAN.end),
    }
}

/// Builds list AST from pest pairs
fn build_list_from_children(
    children: Vec<Pair<Rule>>,
    span: Span,
    state: &mut ParserState,
) -> ExpressionParseResult {
    let ast_nodes = children
        .into_iter()
        .map(|p| build_ast_from_rule(p, state))
        .collect::<Result<Vec<_>, _>>()?;
    Ok(spanned_expr!(Expr::List(ast_nodes, span), span))
}

/// Creates an empty list AST node
fn create_empty_list() -> AstNode {
    spanned_expr!(Expr::List(vec![], EMPTY_SPAN), EMPTY_SPAN)
}

/// Creates a do block AST node from multiple expressions
fn create_do_block(ast_nodes: Vec<AstNode>) -> AstNode {
    let span = calculate_span(&ast_nodes);
    let do_symbol = spanned_expr!(Expr::Symbol(DO_SYMBOL.to_string(), span), span);
    let mut list_items = Vec::with_capacity(ast_nodes.len() + 1);
    list_items.push(do_symbol);
    list_items.extend(ast_nodes);
    spanned_expr!(Expr::List(list_items, span), span)
}

// ============================================================================
// VALIDATION FUNCTIONS
// ============================================================================

/// Validates path components for correctness
fn validate_path_components(
    components: &[&str],
    span: Span,
    state: &mut ParserState,
) -> Result<(), SutraError> {
    let has_invalid_component = components
        .iter()
        .any(|&component| component.is_empty() || component == "..");

    if has_invalid_component {
        return Err(errors::parse_invalid_value(
            "path",
            components.join("."),
            &state.source,
            to_source_span(span),
        )
        .with_suggestion("Use valid path components separated by dots"));
    }

    Ok(())
}

/// Validates and extracts parameter information
fn validate_and_extract_parameter(
    param_item: &Pair<Rule>,
    found_rest: bool,
    state: &mut ParserState,
) -> Result<(String, bool), SutraError> {
    let span = get_span(param_item);
    match param_item.as_rule() {
        Rule::symbol if !found_rest => Ok((extract_symbol(param_item, state)?, false)),
        Rule::spread_arg if !found_rest => {
            let mut spread_inner = param_item.clone().into_inner();
            let symbol_pair = spread_inner.next().ok_or_else(|| {
                errors::parse_malformed("spread", &state.source, to_source_span(span))
                    .with_suggestion("Provide a symbol after ... operator")
            })?;
            Ok((extract_symbol(&symbol_pair, state)?, true))
        }
        Rule::symbol => Err(errors::parse_parameter_order(
            &state.source,
            to_source_span(span),
            to_source_span(span),
        )),
        _ => Err(errors::parse_invalid_value(
            "parameter",
            format!("{:?}", param_item.as_rule()),
            &state.source,
            to_source_span(span),
        )
        .with_suggestion("Parameters must be symbols or spread operators")),
    }
}

/// Extracts symbol string from a pest pair
fn extract_symbol(pair: &Pair<Rule>, state: &mut ParserState) -> SymbolParseResult {
    if pair.as_rule() != Rule::symbol {
        return Err(errors::parse_malformed(
            "symbol",
            &state.source,
            to_source_span(get_span(pair)),
        )
        .with_suggestion("Expected a symbol"));
    }
    Ok(pair.as_str().to_string())
}

/// Validates and builds path AST from symbol text
fn validate_and_build_path(
    symbol_text: &str,
    span: Span,
    state: &mut ParserState,
) -> ExpressionParseResult {
    let path_components: Vec<_> = symbol_text.split('.').collect();
    validate_path_components(&path_components, span, state)?;
    let path = Path(path_components.into_iter().map(String::from).collect());
    Ok(spanned_expr!(Expr::Path(path, span), span))
}

/// Unescapes string literal content
fn unescape_string(pair: Pair<Rule>) -> SymbolParseResult {
    let inner_str = &pair.as_str()[1..pair.as_str().len() - 1];
    let mut result = String::with_capacity(inner_str.len());
    let mut chars = inner_str.chars();

    while let Some(character) = chars.next() {
        if character != '\\' {
            result.push(character);
            continue;
        }
        match chars.next() {
            Some('n') => result.push('\n'),
            Some('t') => result.push('\t'),
            Some('\\') => result.push('\\'),
            Some('"') => result.push('"'),
            Some(other) => {
                result.push('\\');
                result.push(other);
            }
            None => result.push('\\'),
        }
    }
    Ok(result)
}

/// Extracts parameter list and body from special forms
fn extract_form_parts(
    pair: Pair<Rule>,
    state: &mut ParserState,
) -> Result<(AstNode, AstNode, Span), SutraError> {
    let span = get_span(&pair);
    let mut form_pairs = pair.clone().into_inner();

    let param_list_pair = form_pairs.next().ok_or_else(|| {
        errors::parse_missing("parameter list", &state.source, to_source_span(span))
    })?;
    let param_list = build_param_list_ast(param_list_pair, state)?;

    let body_pair = form_pairs.next().ok_or_else(|| {
        errors::parse_missing("function body", &state.source, to_source_span(span))
    })?;
    let body = build_expression_ast(body_pair, state)?;

    Ok((param_list, body, span))
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

/// Creates parse error from pest error
fn create_parse_error(e: Error<Rule>, state: &mut ParserState) -> SutraError {
    let error_span = pest_location_to_span(e.location.clone());
    let (custom_msg, help, diagnostic_span) =
        improve_parse_error_message(&e.to_string(), state, error_span);

    let mut err =
        errors::parse_malformed(custom_msg, &state.source, to_source_span(diagnostic_span));
    if let Some(help_str) = help {
        err = err.with_suggestion(help_str);
    }
    err
}

/// Converts pest parse errors to user-friendly SutraError messages
///
/// This function applies a series of heuristics to transform cryptic, low-level
/// errors from the Pest parser into actionable, user-friendly diagnostics.
/// The heuristics are ordered from most specific to most general.
fn improve_parse_error_message(
    msg: &str,
    state: &ParserState,
    error_span: Span,
) -> (String, Option<String>, Span) {
    fn create_error(problem: &str, help: &str, span: Span) -> (String, Option<String>, Span) {
        (problem.to_string(), Some(help.to_string()), span)
    }

    // Heuristic 1: Check for imbalanced parentheses across the whole source.
    // This is a robust fallback for unclosed expression errors.
    let (open, close) = count_parens(&state.source.content);
    if open > close {
        return create_error(
            "Unmatched opening parenthesis",
            "You may have an unclosed expression; check for a missing ')' or '}'.",
            error_span,
        );
    } else if close > open {
        return create_error(
            "Unmatched closing parenthesis",
            "You may have an extra ')' or '}' somewhere in your code.",
            error_span,
        );
    }

    // Heuristic 2: Check for simple, common error patterns from Pest.
    let error_patterns = [
        (
            EXPECTED_CLOSING_PAREN,
            "Unmatched or missing closing parenthesis ')'",
            "Check for missing or extra parentheses in your code.",
        ),
        (
            EXPECTED_CLOSING_BRACE,
            "Unmatched or missing closing brace '}'",
            "Check for missing or extra braces in your code.",
        ),
        (
            EXPECTED_BLOCK,
            "Unmatched or missing closing brace '}'",
            "Check for missing or extra braces in your code.",
        ),
        (
            EXPECTED_STRING,
            "Unmatched or missing closing quote '\"'",
            "Check for missing or extra quotes in your code.",
        ),
        (
            EXPECTED_QUOTE,
            "Unmatched or missing closing quote '\"'",
            "Check for missing or extra quotes in your code.",
        ),
    ];

    for (pattern, problem, help) in &error_patterns {
        if msg.contains(pattern) {
            return create_error(problem, help, error_span);
        }
    }

    // Heuristic 3: Handle generic "expected expr" as a fallback.
    if msg.contains("expected expr") {
        // This often happens with unclosed expressions, which is now caught above.
        // We can provide a slightly more generic message here.
        return create_error(
            "Unexpected or malformed expression syntax",
            "Please check the structure of your code for errors.",
            error_span,
        );
    }

    if msg.contains("expected program") && msg.contains("\"") {
        return create_error(
            "Unmatched or missing closing quote '\"'",
            "Check for missing or extra quotes in your code.",
            error_span,
        );
    }

    (msg.to_string(), None, error_span)
}

/// Counts the number of opening and closing parentheses in a string.
fn count_parens(s: &str) -> (usize, usize) {
    s.chars().fold((0, 0), |(open, close), c| match c {
        '(' | '{' => (open + 1, close),
        ')' | '}' => (open, close + 1),
        _ => (open, close),
    })
}

// Helper to convert ast::Span to miette::SourceSpan
pub fn to_source_span(span: Span) -> SourceSpan {
    SourceSpan::new(span.start.into(), (span.end - span.start).into())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::runtime::source::SourceContext;

    #[test]
    fn test_unmatched_opening_paren_error_message() {
        let source_text = "(a b (c d)";
        let source_context = SourceContext::from_file("test", source_text);
        let result = parse(source_text, source_context);

        match result {
            Err(e) => {
                let error_message = e.to_string();
                // The main `Display` impl doesn't include the help text, so we just check the main message.
                assert!(error_message.contains("Unmatched opening parenthesis"));
            }
            Ok(_) => panic!("Expected a parse error for unclosed expression, but got Ok"),
        }
    }

    #[test]
    fn test_unmatched_closing_paren_error_message() {
        let source_text = "(a b c d))";
        let source_context = SourceContext::from_file("test", source_text);
        let result = parse(source_text, source_context);

        match result {
            Err(e) => {
                let error_message = e.to_string();
                assert!(error_message.contains("Unmatched closing parenthesis"));
            }
            Ok(_) => panic!("Expected a parse error for extra closing paren, but got Ok"),
        }
    }
}
