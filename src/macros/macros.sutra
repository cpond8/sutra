;; ============================================================================
;; SUTRA STANDARD MACRO LIBRARY
;; ============================================================================
;;
;; This file contains all the standard macros for the Sutra language.
;; All macros are implemented using only the atoms and special forms
;; that are actually available in the engine.
;;
;; Available atoms: +, -, *, /, mod, abs, min, max, len, car, cdr, cons,
;;                  eq?, gt?, lt?, gte?, lte?, not, has?
;;                  core/set!, core/get, core/del!, core/exists?
;;                  list, core/push!, core/pull!, core/str+
;;                  print, rand
;;                  do, error, apply
;;                  lambda, let
;;
;; ============================================================================
;; CORE CONTROL FLOW
;; ============================================================================

;; cond: Multi-branch conditional
;; (cond ((test1 expr1) (test2 expr2) (else exprN)))
(define (cond ...rest)
  (if (null? rest)
      nil
      (let ((clause (car rest)))
        (let ((test (car clause))
              (expr (cadr clause)))
          (if (eq? test 'else)
              expr
              (if test
                  expr
                  (apply cond (cdr rest))))))))

;; when: Execute body when condition is true
;; (when condition ...rest)
(define (when condition ...rest)
  (if condition
      (apply do rest)
      nil))

;; ============================================================================
;; ASSIGNMENT & STATE
;; ============================================================================

;; mul!: Multiply value at path
;; (mul! path value)
(define (mul! path value)
  (core/set! path (* (core/get path) value)))

;; div!: Divide value at path
;; (div! path value)
(define (div! path value)
  (core/set! path (/ (core/get path) value)))

;; push!: Push values to collection
;; (push! path ...rest)
(define (push! path ...rest)
  (apply core/push! path rest))

;; pull!: Pull values from collection
;; (pull! path ...rest)
(define (pull! path ...rest)
  (apply core/pull! path rest))

;; ============================================================================
;; PREDICATES & LOGIC
;; ============================================================================

;; exists?: Check if path exists
;; (exists? path)
(define (exists? path)
  (core/exists? path))

;; and: Short-circuiting logical AND
;; (and a b c)
(define (and ...rest)
  (if (null? rest)
      true
      (if (car rest)
          (apply and (cdr rest))
          false)))

;; or: Short-circuiting logical OR
;; (or a b c)
(define (or ...rest)
  (if (null? rest)
      false
      (if (car rest)
          (car rest)
          (apply or (cdr rest)))))

;; empty?: Check if collection is empty
;; (empty? collection)
(define (empty? collection)
  (eq? (len collection) 0))

;; ============================================================================
;; PREDICATE ALIASES
;; ============================================================================

;; =: Equality alias for eq?
;; (= x y)
(define (= ...rest)
  (apply eq? rest))

;; is?: Equality alias for eq?
;; (is? x y)
(define (is? ...rest)
  (apply eq? rest))

;; >: Greater than alias for gt?
;; (> x y)
(define (> ...rest)
  (apply gt? rest))

;; over?: Greater than alias for gt?
;; (over? x y)
(define (over? ...rest)
  (apply gt? rest))

;; <: Less than alias for lt?
;; (< x y)
(define (< ...rest)
  (apply lt? rest))

;; under?: Less than alias for lt?
;; (under? x y)
(define (under? ...rest)
  (apply lt? rest))

;; >=: Greater than or equal alias for gte?
;; (>= x y)
(define (>= ...rest)
  (apply gte? rest))

;; at-least?: Greater than or equal alias for gte?
;; (at-least? ...rest)
(define (at-least? ...rest)
  (apply gte? rest))

;; <=: Less than or equal alias for lte?
;; (<= x y)
(define (<= ...rest)
  (apply lte? rest))

;; at-most?: Less than or equal alias for lte?
;; (at-most? ...rest)
(define (at-most? ...rest)
  (apply lte? rest))

;; ============================================================================
;; STRING UTILITIES
;; ============================================================================

;; str+: Concatenate strings
;; (str+ "foo" "bar" "baz")
(define (str+ ...rest)
  (apply core/str+ rest))

;; join-str+: Join strings with separator
;; (join-str+ " " "a" "b" "c")
(define (join-str+ sep ...rest)
  (if (null? rest)
      ""
      (if (null? (cdr rest))
          (car rest)
          (core/str+ (car rest) sep (apply join-str+ sep (cdr rest))))))

;; display: Print multiple values
;; (display "hello" 123 true)
(define (display ...rest)
  (if (null? rest)
      (print "")
      (if (null? (cdr rest))
          (print (car rest))
          (do
            (print (car rest))
            (apply display (cdr rest))))))

;; ============================================================================
;; TEST HARNESS
;; ============================================================================

;; test: Define test case
;; (test "name" (expect ...) body...)
(define (test name expect ...rest)
  (do
    (print "Running test: ")
    (print name)
    (apply do rest)
    (print "Test passed: ")
    (print name)))

;; expect: Declare test expectations
;; (expect ...rest)
(define (expect ...rest)
  (if (null? rest)
      true
      (if (car rest)
          (apply expect (cdr rest))
          (error "Test expectation failed"))))

;; ============================================================================
;; LIST & UTILITY HELPERS
;; ============================================================================

;; cadr: Second element of list
;; (cadr (list 1 2 3))
(define (cadr lst)
  (car (cdr lst)))

;; null?: Check if list is empty
;; (null? (list))
(define (null? lst)
  (eq? (len lst) 0))

;; append: Append two lists
;; (append l1 l2)
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))

;; map: Map function over list
;; (map f lst)
(define (map f lst)
  (if (null? lst)
      (list)
      (cons (f (car lst)) (map f (cdr lst)))))

;; ============================================================================
;; CONTROL FLOW HELPERS
;; ============================================================================

;; for-each: Loop over collection
;; (for-each var collection ...rest)
(define (for-each var collection ...rest)
  (if (null? collection)
      nil
      (let ((current (car collection))
            (rest (cdr collection)))
        (let ((var current))
          (do
            (apply do rest)
            (if (null? rest)
                nil
                (apply for-each var rest rest)))))))
