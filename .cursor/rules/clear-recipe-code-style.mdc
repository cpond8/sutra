---
description: Clear recipe approach for complex functional code - prioritize simplicity, readability, and explicit control flow over functional purity
alwaysApply: false
---
# Clear Recipe Code Style

## Core Philosophy

Always apply the "clear recipe" approach to complex or highly dense functional code with long chained logic. Aim for the simplest and most concise solution with the developer reading it in mind.

## Key Principles

### 1. Early Validation Pattern
```rust
// GOOD: Early returns with clear validation
let Expr::List(items, span) = &*expr.value else {
    return Err(err_msg!(Validation, ERROR_EXPECTED_LIST_FORM));
};

if items.len() < min_args {
    return Err(create_arity_error(op_name, min_args - 1, items.len().saturating_sub(1)));
}
```

### 2. Linear Flow
- **Top-to-bottom logic** with minimal nesting
- **Early returns** instead of deep conditional structures
- **Self-documenting** code that reads like pseudocode
- **Isolated concerns** - each step is clear and separate
- **Direct imperative style** - unwind complex operations into basic steps

### 3. Simple Patterns
- Use **`let-else` patterns** for early validation
- **Consistent error handling** - same patterns throughout
- **Minimal variable declarations** - only what's necessary
- **Clear naming** - variables that explain themselves
- **Direct imperative style** - unwind complex operations into basic steps

## What to Avoid

### BAD: Complex Nested Match Statements
```rust
// BAD: Deep nesting with mixed concerns
match &*expr.value {
    Expr::List(items, span) if items.len() >= min_args => {
        // Complex logic mixed with validation
    }
    Expr::List(items, _) => {
        // Error handling mixed with success logic
    }
    _ => { /* format error */ }
}
```

### BAD: Long Functional Chains
```rust
// BAD: Awkward functional chains
.collect::<Result<Vec<_>, _>>()?

// BAD: Complex nested operations
items.iter()
    .map(|item| match &*item.value {
        Expr::Symbol(s, _) | Expr::String(s, _) => Ok(s.clone()),
        _ => Err(err_msg!(Validation, "Path elements must be symbols or strings")),
    })
    .collect::<Result<Vec<_>, _>>()?
```

### BAD: Mixed Success/Error Logic
```rust
// BAD: Success and error paths in same blocks
match &*expr.value {
    Expr::List(items, span) if items.len() >= min_args => {
        // Success logic
    }
    Expr::List(items, _) => {
        // Error logic mixed in
    }
}
```

## Target Style

### GOOD: Clear Recipe Pattern
```rust
// Validate → Transform → Return
let Expr::List(items, span) = &*expr.value else {
    return Err(error);
};

if condition {
    return Err(error);
}

let result = build_simple_thing();
Ok(result)
```

### GOOD: Self-Documenting Structure
```rust
fn create_flexible_path_op(expr: &AstNode, op_name: &str, min_args: usize) -> MacroExpansionResult {
    // 1. Validate expression type
    let Expr::List(items, span) = &*expr.value else {
        return Err(err_msg!(Validation, ERROR_EXPECTED_LIST_FORM));
    };

    // 2. Validate arity
    if items.len() < min_args {
        return Err(create_arity_error(op_name, min_args - 1, items.len().saturating_sub(1)));
    }

    // 3. Build result
    let mut new_items = vec![create_symbol(op_name, span)];
    if items.len() > 1 {
        new_items.push(create_canonical_path(&items[1])?);
        new_items.extend_from_slice(&items[2..]);
    }

    Ok(create_ast_list(new_items, *span))
}

// GOOD: Direct imperative style for complex operations
fn expr_to_path(expr: &AstNode) -> Result<Path, SutraError> {
    let value = &*expr.value;

    // Handle dotted symbol syntax: `player.score` or plain symbol: `player`
    if let Expr::Symbol(s, _) = value {
        return Ok(Path(s.split('.').map(String::from).collect()));
    }

    // Handle already parsed path: `player.health` (from parser)
    if let Expr::Path(path, _) = value {
        return Ok(path.clone());
    }

    // Handle list syntax: `(path player score)`
    if let Expr::List(items, _) = value {
        let mut parts = Vec::new();

        for item in items {
            let item_value = &*item.value;
            match item_value {
                Expr::Symbol(s, _) | Expr::String(s, _) => parts.push(s.clone()),
                _ => return Err(err_msg!(Validation, "Path elements must be symbols or strings")),
            }
        }

        return Ok(Path(parts));
    }

    // Fallback for unsupported expression types
    Err(err_msg!(Validation, "Expression cannot be converted to a path"))
}
```

## Benefits

- **Readability**: Each step is obvious and isolated
- **Maintainability**: Easy to modify individual validation steps
- **Debugging**: Can easily add breakpoints at each validation point
- **Consistency**: Same patterns throughout the codebase
- **Reduced cognitive load**: Linear flow is easier to follow

## When to Apply

Apply this approach to:
- Complex nested `match` statements
- Long functional chains with `.collect()` and `?` operators
- Functions with mixed success/error logic
- Deep conditional nesting
- Any code that's hard to follow or debug
- Complex functional operations that can be unwound into basic steps
- Nested iterator chains that obscure the logic flow

## Priority

**Developer experience first**: Clarity, maintainability, and debuggability over functional purity or cleverness. The goal is code that any developer can immediately understand and modify confidently.
