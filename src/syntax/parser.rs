// # Sutra Parser: Grammar-to-AST Mapping
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/syntax/grammar.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.
//
//!
//! # Sutra Parser: Grammar-to-AST Mapping
//!
//! | PEG Rule      | AST Node         | Notes                         |
//! |---------------|------------------|-------------------------------|
//! | program       | Vec<Expr>        | Top-level expressions; see note below |
//! | expr          | Expr             | Delegates to subrules         |
//! | list          | Expr::List       | Regular list only             |
//! | dotted_list   | (REMOVED)        | (REMOVED)                     |
//! | block         | Expr::List       | Brace blocks                  |
//! | atom          | Expr             | Number, Bool, String, Symbol  |
//! | number        | Expr::Number     |                               |
//! | boolean       | Expr::Bool       |                               |
//! | string        | Expr::String     |                               |
//! | symbol        | Expr::Symbol     |                               |
//!
//! **Span conventions:**
//! - All AST nodes carry a span covering the full source range of the parsed form.
//! - For dotted lists, the dot is represented as `Expr::Symbol(".")` with the span of the entire dotted list (not just the dot token).
//! - This is intentional for simplicity and is documented for downstream consumers.
//!
//! **Program node representation:**
//! - The public `parse` API returns a `Vec<Expr>` for top-level forms.
//! - Internally, `build_program` returns an `Expr::List` for uniformity, but this is unwrapped by `parse`.
//! - If a canonical program node is ever needed, document and update accordingly.

use crate::ast::{AstNode, Expr, Span, WithSpan};
use crate::SutraError;
use crate::{err_ctx, err_msg};
use once_cell::sync::Lazy;
use pest::error::InputLocation;
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;
use std::collections::HashMap;

// This derive macro generates the parser implementation from our grammar file.
#[derive(Parser)]
#[grammar = "syntax/grammar.pest"]
struct SutraParser;

/// Parses a source string into a vector of top-level Sutra `Expr` AST nodes.
///
/// This function is the sole public entry point to the parser. It is purely
/// syntactic and does not add any semantic wrappers like `(do ...)`.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Vec<Expr>)` - A vector of expressions found at the top level of the source.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source: &str) -> Result<Vec<AstNode>, SutraError> {
    // `SutraParser::parse` attempts to match the `program` rule from the grammar.
    // If it fails, it returns a `pest` error, which we map to our `SutraError`.
    let pairs = SutraParser::parse(Rule::program, source).map_err(|e| {
        let span = match e.location {
            pest::error::InputLocation::Pos(pos) => Span { start: pos, end: pos },
            pest::error::InputLocation::Span((start, end)) => Span { start, end },
        };
        err_ctx!(Parse, e.to_string(), source, span)
    })?;

    // The `program` rule is guaranteed to have one inner pair (itself) if parsing succeeds.
    let root_pair = pairs.peek().ok_or_else(|| {
        err_ctx!(
            Parse,
            "Parser generated an empty tree, this should not happen.",
            source,
            Span {
                start: 0,
                end: source.len()
            }
        )
    })?;

    // We build the AST from all expressions found inside the `program` rule.
    root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(|p| build_ast_from_pair(p, source))
        .collect()
}

/// Utility: Wraps a list of AST nodes in a (do ...) form if needed.
pub fn wrap_in_do(exprs: Vec<AstNode>) -> AstNode {
    use crate::ast::{Expr, Span, WithSpan};
    match exprs.len() {
        0 => WithSpan {
            value: Expr::List(vec![], Span { start: 0, end: 0 }).into(),
            span: Span { start: 0, end: 0 },
        },
        1 => exprs.into_iter().next().expect("wrap_in_do: exprs should have at least one element"),
        _ => {
            let span = Span {
                start: exprs.first().map(|n| n.span.start).unwrap_or(0),
                end: exprs.last().map(|n| n.span.end).unwrap_or(0),
            };
            let do_symbol = WithSpan {
                value: Expr::Symbol("do".to_string(), span).into(),
                span,
            };
            let mut items = Vec::with_capacity(exprs.len() + 1);
            items.push(do_symbol);
            items.extend(exprs);
            WithSpan {
                value: Expr::List(items, span).into(),
                span,
            }
        }
    }
}

// Utility function for consistent span extraction
fn get_span(pair: &pest::iterators::Pair<Rule>) -> Span {
    Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    }
}

// Type alias for AST builder functions
pub type AstBuilderFn = fn(Pair<Rule>, &str) -> Result<AstNode, SutraError>;

// Static map from Rule to handler function
pub static AST_BUILDERS: Lazy<HashMap<Rule, AstBuilderFn>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert(Rule::program, build_program as AstBuilderFn);
    m.insert(Rule::expr, build_expr as AstBuilderFn);
    m.insert(Rule::list, build_list as AstBuilderFn);
    m.insert(Rule::param_list, build_param_list as AstBuilderFn);
    m.insert(Rule::block, build_block as AstBuilderFn);
    m.insert(Rule::number, build_number as AstBuilderFn);
    m.insert(Rule::boolean, build_boolean as AstBuilderFn);
    m.insert(Rule::string, build_string as AstBuilderFn);
    m.insert(Rule::symbol, build_symbol as AstBuilderFn);
    m.insert(Rule::quote, build_quote as AstBuilderFn);
    m.insert(Rule::define_form, build_define_form as AstBuilderFn);
    m.insert(Rule::atom, build_atom as AstBuilderFn);
    m.insert(Rule::spread_arg, build_spread_arg as AstBuilderFn);
    m.insert(Rule::list_elem, build_list_elem as AstBuilderFn);
    m
});

// Dispatcher: looks up the handler in the map and calls it
fn build_ast_from_pair(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    AST_BUILDERS
        .get(&pair.as_rule())
        .ok_or_else(|| {
            err_ctx!(
                Internal,
                format!("No AST builder for rule: {:?}", pair.as_rule()),
                source,
                get_span(&pair)
            )
        })?(pair, source)
}

// Private combinator for mapping children to Expr::List
fn map_children_to_list<'a>(
    children: Box<dyn Iterator<Item = Pair<Rule>> + 'a>,
    span: Span,
    source: &str,
) -> Result<AstNode, SutraError> {
    let exprs = children
        .map(|p| build_ast_from_pair(p, source))
        .collect::<Result<Vec<_>, _>>()?;
    Ok(WithSpan {
        value: Expr::List(exprs, span).into(),
        span,
    })
}

/// Handles the top-level program rule.
///
/// Note: Returns an `Expr::List` for internal uniformity, but the public `parse` API collects top-level forms as a `Vec<Expr>`.
/// If a canonical program node is ever needed, update this convention and document accordingly.
fn build_program(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    map_children_to_list(
        Box::new(
            pair.clone()
                .into_inner()
                .filter(|p| p.as_rule() != Rule::EOI),
        ),
        span,
        source,
    )
}

/// Handles expr rule (delegates to subrules).
fn build_expr(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| {
        err_ctx!(
            Internal,
            format!("Empty expr pair: {}", pair.as_str()),
            source,
            get_span(&pair)
        )
    })?;
    build_ast_from_pair(sub, source)
}

/// Handles list rule (proper lists only).
fn build_list(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    map_children_to_list(Box::new(pair.clone().into_inner()), span, source)
}

/// Parses a parameter list into an Expr::ParamList using a maximally functional, type-driven approach.
///
/// # Invariants
/// - All required parameters (symbols) must come before any rest parameter ("... rest").
/// - Only one rest parameter is allowed, and it must be the last.
/// - Any violation results in a precise error.
///
/// # Errors
/// - Required parameter after rest: error.
/// - Multiple rest parameters: error.
/// - Non-symbol after ...: error.
/// - Invalid parameter type: error.
///
/// # Safety
/// This function assumes the CST structure matches the grammar. If the grammar changes, review this logic.
///
/// # Example
/// ```ignore
/// let pair = SutraParser::parse(Rule::param_list, "x y ...rest").unwrap().next().unwrap();
/// let result = build_param_list(pair).unwrap();
/// assert!(matches!(result.value, Expr::ParamList(_)));
/// ```
// Helper: construct param_list errors
fn param_list_error(msg: impl Into<String>, source: &str, span: Span) -> SutraError {
    err_ctx!(Internal, msg.into(), source, span)
}
// Helper: handle spread_arg
fn extract_spread_symbol(item: &Pair<Rule>, source: &str) -> Result<String, SutraError> {
    let mut spread_inner = item.clone().into_inner();
    let symbol_pair = spread_inner.next().ok_or_else(|| {
        param_list_error("spread_arg: missing symbol after '...'", source, get_span(item))
    })?;
    as_symbol(&symbol_pair)
}

fn build_param_list(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();

    // The param_list rule contains a single param_items rule
    let param_items_pair = inner.next().ok_or_else(|| {
        param_list_error("param_list: Missing param_items", source, span)
    })?;

    let mut required_params = Vec::new();
    let mut rest_param = None;
    let mut found_rest = false;

    for item in param_items_pair.into_inner() {
        match item.as_rule() {
            Rule::symbol if !found_rest => {
                required_params.push(as_symbol(&item)?);
            }
            Rule::spread_arg => {
                if found_rest {
                    return Err(param_list_error(
                        "param_list: Multiple rest parameters are not allowed",
                        source,
                        get_span(&item),
                    ));
                }
                found_rest = true;
                rest_param = Some(extract_spread_symbol(&item, source)?);
            }
            Rule::symbol if found_rest => {
                return Err(param_list_error(
                    "param_list: Required parameter after rest parameter",
                    source,
                    get_span(&item),
                ));
            }
            _ => {
                return Err(param_list_error(
                    format!("param_list: Invalid element '{:?}'", item.as_rule()),
                    source,
                    get_span(&item),
                ));
            }
        }
    }

    Ok(WithSpan {
        value: Expr::ParamList(crate::ast::ParamList {
            required: required_params,
            rest: rest_param,
            span,
        })
        .into(),
        span,
    })
}

fn as_symbol(pair: &Pair<Rule>) -> Result<String, SutraError> {
    if pair.as_rule() != Rule::symbol {
        return Err(err_msg!(Internal, "Expected symbol, found {:?}", pair.as_rule()));
    }
    Ok(pair.as_str().to_string())
}

/// Handles brace-block rule (which is just a list).
fn build_block(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    map_children_to_list(Box::new(pair.clone().into_inner()), span, source)
}

fn build_atom(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let inner = pair.clone().into_inner().next().ok_or_else(|| {
        err_ctx!(
            Internal,
            format!("Empty atom pair: {}", pair.as_str()),
            source,
            get_span(&pair)
        )
    })?;
    build_ast_from_pair(inner, source)
}

fn build_number(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    let n = pair
        .as_str()
        .parse::<f64>()
        .map_err(|e| err_ctx!(Parse, format!("Number parse error: {}", e), source, span))?;
    Ok(WithSpan {
        value: Expr::Number(n, span).into(),
        span,
    })
}

fn build_boolean(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    match pair.as_str() {
        "true" => Ok(WithSpan {
            value: Expr::Bool(true, span).into(),
            span,
        }),
        "false" => Ok(WithSpan {
            value: Expr::Bool(false, span).into(),
            span,
        }),
        _ => Err(err_ctx!(
            Internal,
            format!("Invalid boolean literal: {}", pair.as_str()),
            source,
            span
        )),
    }
}

fn build_string(pair: Pair<Rule>, _source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    Ok(WithSpan {
        value: Expr::String(unescape_string(pair.clone())?, span).into(),
        span,
    })
}

fn build_symbol(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    let s = pair.as_str();

    // If a symbol contains a dot, we treat it as a path and parse it.
    // Otherwise, it's a regular symbol. This is the point where we can
    // enforce security validation on paths.
    if s.contains('.') {
        let components: Vec<_> = s.split('.').map(|s| s.to_string()).collect();

        // SECURITY: Validate against path traversal and empty components.
        for component in &components {
            if component == ".." {
                return Err(err_ctx!(
                    Parse,
                    "Path traversal using '..' is forbidden.",
                    source,
                    span
                ));
            }
            if component.is_empty() {
                return Err(err_ctx!(
                    Parse,
                    "Path cannot contain empty components (e.g., 'a..b').",
                    source,
                    span
                ));
            }
        }

        Ok(WithSpan {
            value: Expr::Path(crate::runtime::path::Path(components), span).into(),
            span,
        })
    } else {
        Ok(WithSpan {
            value: Expr::Symbol(s.to_string(), span).into(),
            span,
        })
    }
}

/// Pure helper function to unescape a string from a `pest` `Pair`.
///
/// Note: Only supports basic escapes (\n, \t, \\, \"). Unicode (\uXXXX) and hex/octal escapes are NOT supported.
/// This is sufficient for current narrative scripting, but should be extended if such escapes are needed in the future.
fn unescape_string(pair: Pair<Rule>) -> Result<String, SutraError> {
    // The `string` rule in the grammar is `@{ "\"" ~ inner ~ "\"" }`.
    // `pair.as_str()` gives us the full text, including the surrounding quotes.
    let full_str = pair.as_str();

    // We slice the string to remove the first and last characters (the quotes).
    // This is simpler and more robust than traversing the CST, even if it's
    // slightly less performant for very long strings. The correctness and
    // simplicity trade-off is worth it here.
    let inner_str = &full_str[1..full_str.len() - 1];

    // Now, we manually unescape the recognized sequences.
    let mut result = String::with_capacity(inner_str.len());
    let mut chars = inner_str.chars();
    while let Some(c) = chars.next() {
        if c != '\\' {
            result.push(c);
            continue;
        }
        match chars.next() {
            Some('n') => result.push('\n'),
            Some('t') => result.push('\t'),
            Some('\\') => result.push('\\'),
            Some('"') => result.push('"'),
            // If we encounter an invalid escape, we just push the characters
            // literally. The grammar should prevent this, but this is safer.
            Some(other) => {
                result.push('\\');
                result.push(other);
            }
            // A dangling escape at the end of a string.
            None => result.push('\\'),
        }
    }
    Ok(result)
}

/// Canonical CST node for the parsing pipeline (modular, interface-driven).
#[derive(Debug, Clone, PartialEq)]
pub struct SutraCstNode {
    pub rule: String, // Use String for rule name for now; can be enum if desired
    pub children: Vec<SutraCstNode>,
    pub span: crate::ast::Span,
    // Optionally: text, parent, etc.
}

#[derive(Debug, Clone, PartialEq)]
pub enum SutraCstParseError {
    Syntax {
        span: crate::ast::Span,
        message: String,
    },
    Incomplete {
        span: crate::ast::Span,
        message: String,
    },
    // ...
}

/// Canonical trait for a CST parser (modular pipeline contract).
pub trait SutraCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError>;
    fn traverse<'a>(&'a self, node: &'a SutraCstNode) -> SutraCstTraversal<'a>;
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(
        &'a self,
        node: &'a SutraCstNode,
        visitor: F,
        order: TraversalOrder,
    );
}

/// Iterator for CST traversal (DFS/BFS).
pub struct SutraCstTraversal<'a> {
    // Implementation details omitted for now
    _phantom: std::marker::PhantomData<&'a SutraCstNode>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TraversalOrder {
    DepthFirst,
    BreadthFirst,
}

/// Real CST parser using pest and the canonical grammar.
pub struct PestCstParser;

impl SutraCstParser for PestCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError> {
        let pairs = SutraParser::parse(Rule::program, input).map_err(|e| {
            let span = match e.location {
                InputLocation::Pos(pos) => crate::ast::Span {
                    start: pos,
                    end: pos,
                },
                InputLocation::Span((start, end)) => crate::ast::Span { start, end },
            };
            SutraCstParseError::Syntax {
                span,
                message: e.to_string(),
            }
        })?;
        let root_pair = pairs.peek().ok_or_else(|| SutraCstParseError::Incomplete {
            span: crate::ast::Span {
                start: 0,
                end: input.len(),
            },
            message: "Parser generated an empty tree, this should not happen.".to_string(),
        })?;
        Ok(build_cst_from_pair(root_pair))
    }
    fn traverse<'a>(&'a self, _node: &'a SutraCstNode) -> SutraCstTraversal<'a> {
        SutraCstTraversal {
            _phantom: std::marker::PhantomData,
        }
    }
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(
        &'a self,
        _node: &'a SutraCstNode,
        _visitor: F,
        _order: TraversalOrder,
    ) {
        // Not implemented for now
    }
}

fn build_cst_from_pair(pair: Pair<Rule>) -> SutraCstNode {
    let span = crate::ast::Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    };
    let rule = format!("{:?}", pair.as_rule());
    let children: Vec<SutraCstNode> = pair.clone().into_inner().map(build_cst_from_pair).collect();
    SutraCstNode {
        rule,
        children,
        span,
    }
}

#[cfg(test)]
mod pest_cst_tests {
    use super::*;
    #[test]
    fn pest_cst_parser_parses_simple_program() {
        let parser = PestCstParser;
        let input = "(foo 42)";
        let cst = parser.parse(input).unwrap();
        assert_eq!(cst.rule, "program");
        assert_eq!(cst.children.len(), 2); // expr + EOI
        let expr = &cst.children[0];
        assert_eq!(expr.rule, "expr");
        assert_eq!(expr.children.len(), 1);
        let list = &expr.children[0];
        assert_eq!(list.rule, "list");
        assert_eq!(list.span.start, 0);
        assert_eq!(list.span.end, 8);
    }
}

// Add missing handler for quote
fn build_quote(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    let quoted_expr = build_expr(
        pair.clone().into_inner().next().ok_or_else(|| {
            err_ctx!(Internal, "Empty quote", source, get_span(&pair))
        })?,
        source,
    )?;
    Ok(WithSpan {
        value: Expr::Quote(Box::new(quoted_expr), span).into(),
        span,
    })
}

// Add missing handler for define_form
fn build_define_form(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();

    // The grammar: define_form = { "(" ~ "define" ~ param_list ~ expr ~ ")" }
    // The CST children are: param_list, expr (body)
    let param_list_pair = inner.next().ok_or_else(|| {
        err_ctx!(
            Internal,
            "Missing parameter list in define form",
            source,
            span
        )
    })?;
    let param_list_node = build_param_list(param_list_pair, source)?;
    let Expr::ParamList(full_params) = &*param_list_node.value else {
        return Err(err_ctx!(
            Internal,
            "Expected ParamList AST node for define form parameters",
            source,
            span
        ));
    };

    // The first element of the param_list is the macro name
    let name = full_params.required.first().cloned().ok_or_else(|| {
        err_ctx!(
            Internal,
            "Define form must have a name in its parameter list",
            source,
            span
        )
    })?;

    // Create a new ParamList without the macro name (the actual parameters)
    let actual_params = crate::ast::ParamList {
        required: full_params.required[1..].to_vec(),
        rest: full_params.rest.clone(),
        span: full_params.span,
    };

    let body_pair = inner.next().ok_or_else(|| {
        err_ctx!(
            Internal,
            "Missing body expression in define form",
            source,
            span
        )
    })?;
    let body = build_expr(body_pair, source)?;

    Ok(WithSpan {
        value: Expr::Define {
            name,
            params: actual_params,
            body: Box::new(body),
            span,
        }
        .into(),
        span,
    })
}

fn build_spread_arg(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    let span = get_span(&pair);
    let symbol_expr = build_symbol(
        pair.clone().into_inner().next().ok_or_else(|| {
            err_ctx!(Internal, "Empty spread", source, get_span(&pair))
        })?,
        source,
    )?;
    Ok(WithSpan {
        value: Expr::Spread(Box::new(symbol_expr)).into(),
        span,
    })
}

fn build_list_elem(pair: Pair<Rule>, source: &str) -> Result<AstNode, SutraError> {
    build_expr(pair, source)
}
