;; macros.sutra - Standard Macro Library (Self-Hosted)
;;
;; Canonical macro definitions for Sutra, organized and documented per canonical-language-reference.md.
;; Each section groups related macros, with doc comments describing purpose, arity, usage, and expansion.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1. Core Control Flow Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; cond: Multi-branch conditional. Expands to nested ifs. Validates clauses.
;; Arity: 1.. (at least one clause)
;; Usage: (cond ((test1 expr1) (test2 expr2) ... (else exprN)))
(define (cond ...clauses)
  (if (null? clauses)
      (error "`cond` macro requires at least one clause.")
      (let ((err (cond-validate clauses)))
        (if err
            (error err)
            (cond-expand clauses)))))

;; Helper: cond-validate
;; Returns false if valid, else an error message string
(define (cond-validate clauses)
  (let ((n (len clauses)))
    (let ((found-else false))
      (letrec
        ((validate
          (lambda (i)
            (if (gte? i n)
                false
                (let ((clause (get clauses i)))
                  (if (not (list? clause))
                      (str "Each `cond` clause must be a list. Problematic clause: " clause)
                      (if (not (eq? (len clause) 2))
                          (str "Each `cond` clause must be a list of two elements. Problematic clause: " clause)
                          (let ((test (car clause)))
                            (if (eq? test 'else)
                                (if found-else
                                    (str "`else` clause must be unique. Clause heads: " (map car clauses))
                                    (if (not (eq? i (- n 1)))
                                        (str "`else` clause must be the last clause in `cond`. Clause heads: " (map car clauses))
                                        (begin (set! found-else true) (validate (+ i 1)))))
                                (validate (+ i 1)))))))))))
        (validate 0)))))

;; Helper: cond-expand recursively expands validated clauses to nested ifs
(define (cond-expand clauses)
  (if (null? clauses)
      (error "`cond` macro requires at least one clause.")
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (let ((test (car first))
              (expr (cadr first)))
          (if (eq? test 'else)
              expr
              (list 'if test expr (cond-expand rest)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Assignment & State Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; inc!: Increment value at path by 1.
;; Arity: 1 (path)
;; Usage: (inc! player.score)
;; Expands to: (core/set! path (+ (get path) 1))
(define (inc! path)
  (list 'core/set! path (list '+ (list 'get path) 1)))

;; dec!: Decrement value at path by 1.
;; Arity: 1 (path)
;; Usage: (dec! player.hp)
;; Expands to: (core/set! path (- (get path) 1))
(define (dec! path)
  (list 'core/set! path (list '- (list 'get path) 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Predicates & Logic Macros (Aliases)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; eq? aliases
;; (= ...args): Canonical equality alias.
(define (= ...args) (eq? ...args))
;; (is? ...args): Canonical equality alias.
(define (is? ...args) (eq? ...args))

;; gt? aliases
(define (> ...args) (gt? ...args))
(define (over? ...args) (gt? ...args))

;; lt? aliases
(define (< ...args) (lt? ...args))
(define (under? ...args) (lt? ...args))

;; gte? aliases
(define (>= ...args) (gte? ...args))
(define (at-least? ...args) (gte? ...args))

;; lte? aliases
(define (<= ...args) (lte? ...args))
(define (at-most? ...args) (lte? ...args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Math & Value Operation Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (No macro definitions here; see atom registry for +, -, *, /, etc.)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. String Utility Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; str+: Concatenate any number of string arguments into a single string.
;; Arity: 0.. (variadic)
;; Usage: (str+ "foo" "bar" "baz") => "foobarbaz"
(define (str+ ...args)
  (core/str+ ...args))

;; join-str+: Join strings with a separator.
;; Arity: 2.. (separator, then strings)
;; Usage: (join-str+ " " "a" "b" "c") => "a b c"
(define (join-str+ sep ...args)
  (letrec ((interleave
            (lambda (acc remaining)
              (if (null? remaining)
                  acc
                  (if (null? acc)
                      (interleave (list (car remaining)) (cdr remaining))
                      (interleave (append acc (list sep (car remaining))) (cdr remaining)))))))
    (apply str+ (interleave '() args))))

;; display: Print multiple values to output, separated by spaces.
;; Arity: 0.. (variadic)
;; Usage: (display "hello" 123 true) => prints "hello 123 true"
(define (display ...args)
  (print (apply join-str+ " " ...args)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6. Test Harness Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; test: Define a new test case.
;; Usage: (test "name" (expect ...) body...)
;; Expands to: (register-test! name expect-form body metadata)
(define (test name expect-form ...body)
  (list 'register-test! name expect-form body (list "span" "unknown" "file" "unknown")))

;; expect: Used within test to declare expectations.
;; Usage: (expect ...conditions)
;; Expands to: (cons 'expect conditions)
(define (expect ...conditions)
  (cons 'expect conditions))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 7. List & Utility Helpers (for macro expansion)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; car: Return first element of list, error if empty.
(define (car lst)
  (if (null? lst)
      (error "car: empty list")
      (get lst 0)))

;; cdr: Return all but first element of list, error if empty.
(define (cdr lst)
  (if (null? lst)
      (error "cdr: empty list")
      (slice lst 1)))

;; cadr: Return second element of list.
(define (cadr lst)
  (car (cdr lst)))

;; null?: True if list is empty.
(define (null? lst)
  (eq? (len lst) 0))

;; append: Append two lists.
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))

;; map: Map a function over a list.
(define (map f lst)
  (if (null? lst)
      '()
      (cons (f (car lst)) (map f (cdr lst)))))

;; cons: Prepend element to list.
(define (cons el lst)
  (core/prepend el lst))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8. Stage 1 Macros (Priorities 1-3)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Assignment Macros (Priority 1)

;; mul!: Multiply value at path
;; Expands to: (core/set! path (* (core/get path) value))
(define (mul! path value)
  (core/set! path (* (core/get path) value)))

;; div!: Divide value at path
;; Expands to: (core/set! path (/ (core/get path) value))
(define (div! path value)
  (core/set! path (/ (core/get path) value)))

;; push!: Push values to collection at path
;; Expands to: (core/push! path ...values)
(define (push! path ...values)
  (core/push! path ...values))

;; pull!: Pull values from collection at path
;; Expands to: (core/pull! path ...values)
(define (pull! path ...values)
  (core/pull! path ...values))

;; Predicate/Logic Macros (Priority 2)

;; exists?: Check if path exists
(define (exists? path)
  (core/exists? path))

;; and: Short-circuiting logical AND
(define (and ...args)
  (if (null? args)
      true
      (if (car args)
          (apply and (cdr args))
          false)))

;; or: Short-circuiting logical OR
(define (or ...args)
  (if (null? args)
      false
      (if (car args)
          (car args)
          (apply or (cdr args)))))

;; empty?: Check if collection is empty
(define (empty? collection)
  (eq? (len collection) 0))

;; has?: Check if value exists in collection
(define (has? collection value)
  (core/has? collection value))

;; Control Flow Macros (Priority 3)

;; when: Execute body when condition is true
(define (when cond ...body)
  (if cond (do ...body)))

;; let: Lexical bindings
(define (let bindings ...body)
  (letrec
    ((process-bindings
      (lambda (binds)
        (if (null? binds)
            (do ...body)
            (let ((binding (car binds)))
              (let ((var (car binding))
                    (val (cadr binding)))
                (set! var val)
                (process-bindings (cdr binds)))))))
    (process-bindings bindings))))

;; for-each: Loop over collection
(define (for-each var collection ...body)
  (let ((index 0)
        (len (len collection)))
    (while (< index len)
      (let ((var (get collection index)))
        (do ...body)
        (set! index (+ index 1))))))
