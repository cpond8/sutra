;; macros.sutra - Standard Macro Library (Self-Hosted)
;;
;; This file contains canonical macro definitions written in the Sutra language.
;; These macros are loaded at startup and registered into the macro system.

;; Helper: cond-validate
;; Returns false if valid, else an error message string
(define (cond-validate clauses)
  (let ((n (len clauses)))
    (let ((found-else false))
      (letrec
        ((validate
          (lambda (i)
            (if (gte? i n)
                false
                (let ((clause (get clauses i)))
                  (if (not (list? clause))
                      (str "Each `cond` clause must be a list. Problematic clause: " clause)
                      (if (not (eq? (len clause) 2))
                          (str "Each `cond` clause must be a list of two elements. Problematic clause: " clause)
                          (let ((test (car clause)))
                            (if (eq? test 'else)
                                (if found-else
                                    (str "`else` clause must be unique. Clause heads: " (map car clauses))
                                    (if (not (eq? i (- n 1)))
                                        (str "`else` clause must be the last clause in `cond`. Clause heads: " (map car clauses))
                                        (begin (set! found-else true) (validate (+ i 1)))))
                                (validate (+ i 1)))))))))))
        (validate 0)))))

;; Helper: cond-expand recursively expands validated clauses to nested ifs
(define (cond-expand clauses)
  (if (null? clauses)
      (error "`cond` macro requires at least one clause.")
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (let ((test (car first))
              (expr (cadr first)))
          (if (eq? test 'else)
              expr
              (list 'if test expr (cond-expand rest)))))))

;; Canonical cond macro with up-front validation and always expands to nested ifs
(define (cond ...clauses)
  (if (null? clauses)
      (error "`cond` macro requires at least one clause.")
      (let ((err (cond-validate clauses)))
        (if err
            (error err)
            (cond-expand clauses)))))

;; List and utility helpers for macro expansion
(define (car lst)
  (if (null? lst)
      (error "car: empty list")
      (get lst 0)))

(define (cdr lst)
  (if (null? lst)
      (error "cdr: empty list")
      (slice lst 1)))

(define (cadr lst)
  (car (cdr lst)))

(define (null? lst)
  (eq? (len lst) 0))

;; Core Dependencies & Helpers
;;
;; The macros in this file depend on several built-in atoms and special forms
;; that must be provided by the engine's runtime.
;;
;; Special Forms (provided by the parser/evaluator):
;; - let, letrec, lambda
;;
;; Built-in Atoms (provided by the atom registry):
;; - get, slice, len, eq?, not, error, str, apply, core/str+
;;
;; The following helpers are defined for use in other macros.

;; Append two lists.
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))

;; Map a function over a list.
(define (map f lst)
  (if (null? lst)
      '()
      (cons (f (car lst)) (map f (cdr lst)))))

;; Prepend an element to a list.
(define (cons el lst)
  (core/prepend el lst))

;; String concatenation macro: str+
;; Concatenates any number of string arguments into a single string.
;; Usage: (str+ "foo" "bar" "baz") => "foobarbaz"
(define (str+ ...args)
  (core/str+ ...args))
;; Join strings with a separator
;; Usage: (join-str+ " " "a" "b" "c") => "a b c"
(define (join-str+ sep ...args)
  (letrec ((interleave
            (lambda (acc remaining)
              (if (null? remaining)
                  acc
                  (if (null? acc)
                      (interleave (list (car remaining)) (cdr remaining))
                      (interleave (append acc (list sep (car remaining))) (cdr remaining)))))))
    (apply str+ (interleave '() args))))

;; Display multiple values to the output, separated by spaces.
;; Usage: (display "hello" 123 true) => prints "hello 123 true"
(define (display ...args)
  (print (apply join-str+ " " ...args)))

;; Comparison operator aliases (canonical forms)
;; Each alias expands to the canonical atom or macro form, supporting full variadic arity.

;; eq? aliases
(define (= ...args) (eq? ...args))
(define (is? ...args) (eq? ...args))

;; gt? aliases
(define (> ...args) (gt? ...args))
(define (over? ...args) (gt? ...args))

;; lt? aliases
(define (< ...args) (lt? ...args))
(define (under? ...args) (lt? ...args))

;; gte? aliases
(define (>= ...args) (gte? ...args))
(define (at-least? ...args) (gte? ...args))

;; lte? aliases
(define (<= ...args) (lte? ...args))
(define (at-most? ...args) (lte? ...args))

;;
;; Test Harness Macros
;;

;; The `test` macro defines a new test case.
;;
;; It takes a name for the test, an `expect` form that specifies
;; the expected outcome, and a body of code to execute.
;;
;; The macro expands into a call to `register-test!`, passing along the
;; test name, expectation, body, and metadata about the source location.
(define (test name expect-form ...body)
  (list 'register-test! name expect-form body (list "span" "unknown" "file" "unknown")))

;; The `expect` macro is used within a `test` to declare expectations.
;; It is a placeholder here and will be parsed by the `register-test!` atom.
(define (expect ...conditions)
  (cons 'expect conditions))

;; Increment and decrement macros
(define (inc! path)
  (list 'core/set! path (list '+ (list 'get path) 1)))

(define (dec! path)
  (list 'core/set! path (list '- (list 'get path) 1)))
