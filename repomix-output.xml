This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cli/
  args.rs
  mod.rs
  output.rs
ast.rs
atom.rs
atoms_std.rs
error.rs
eval.rs
lib.rs
macros_std.rs
macros.rs
main.rs
parser.rs
path.rs
registry.rs
sutra.pest
validate.rs
value.rs
world.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cli/args.rs">
//! Defines the command-line arguments and subcommands for the Sutra CLI.
//!
//! This module uses the `clap` crate with its "derive" feature to create a
//! declarative and type-safe argument parsing structure.

use clap::{Parser, Subcommand};
use std::path::PathBuf;

/// The main CLI argument structure.
#[derive(Debug, Parser)]
#[command(
    name = "sutra",
    version,
    about = "A compositional, emergent, and narrative-rich game engine."
)]
pub struct SutraArgs {
    #[command(subcommand)]
    pub command: Command,
}

/// An enumeration of all available CLI subcommands.
#[derive(Debug, Subcommand)]
pub enum Command {
    /// Full pipeline: parse, expand, validate, eval, and output.
    Run {
        /// The path to the Sutra script file to run.
        #[arg(required = true)]
        file: PathBuf,
    },
    /// Print the fully macro-expanded code.
    Macroexpand {
        /// The path to the Sutra script file to expand.
        #[arg(required = true)]
        file: PathBuf,
    },
    /// Show a stepwise macro expansion trace with diffs.
    Macrotrace {
        /// The path to the Sutra script file to trace.
        #[arg(required = true)]
        file: PathBuf,
    },
    /// Validate a script and show errors/warnings.
    Validate {
        /// The path to the Sutra script file to validate.
        #[arg(required = true)]
        file: PathBuf,
    },
    /// Pretty-print and normalize a script.
    Format {
        /// The path to the Sutra script file to format.
        #[arg(required = true)]
        file: PathBuf,
    },
    /// Discover and run all test scripts in a directory.
    Test {
        /// The path to the directory containing test scripts.
        #[arg(default_value = "tests")]
        path: PathBuf,
    },
    /// List all available macros with their documentation.
    ListMacros,
    /// List all available atoms with their documentation.
    ListAtoms,
}
</file>

<file path="cli/mod.rs">
//! The Sutra Command-Line Interface.
//!
//! This module is the main entry point for all CLI commands and orchestrates
//! the core library functions.

use crate::cli::args::{Command, SutraArgs};
use crate::macros::{MacroRegistry, load_macros_from_file, MacroDef, MacroExpander, SutraMacroContext, SutraMacroExpander};
use crate::{macros_std, parser};
use clap::Parser;
use std::{fs, process};

pub mod args;
pub mod output;

/// The main entry point for the CLI.
pub fn run() {
    let args = SutraArgs::parse();

    // Dispatch to the appropriate subcommand handler.
    let result = match args.command {
        Command::Macrotrace { file } => handle_macrotrace(&file),
        // Other commands will be handled here later.
        _ => {
            println!("Command not yet implemented.");
            Ok(())
        }
    };

    if let Err(e) = result {
        eprintln!("Error: {}", e);
        process::exit(1);
    }
}

use crate::ast::{Expr, Span, WithSpan};

/// Handles the `macrotrace` subcommand.
fn handle_macrotrace(path: &std::path::Path) -> Result<(), Box<dyn std::error::Error>> {
    let filename = path.to_str().ok_or("Invalid filename")?;
    let source = fs::read_to_string(filename)?;
    let ast_nodes = parser::parse(&source).map_err(|e| e.with_source(&source))?;

    let program: WithSpan<Expr> = if ast_nodes.len() == 1 {
        ast_nodes.into_iter().next().unwrap()
    } else {
        let span = Span {
            start: 0,
            end: source.len(),
        };
        let do_symbol = WithSpan {
            value: Expr::Symbol("do".to_string(), span.clone()),
            span: span.clone(),
        };
        let mut items = Vec::with_capacity(ast_nodes.len() + 1);
        items.push(do_symbol);
        items.extend(ast_nodes);
        WithSpan {
            value: Expr::List(items, span.clone()),
            span,
        }
    };

    let mut registry = MacroRegistry::new();
    // Centralized registration of all standard macros.
    macros_std::register_std_macros(&mut registry);

    // Load user-defined/stdlib macros from macros.sutra
    match load_macros_from_file("macros.sutra") {
        Ok(macros) => {
            for (name, template) in macros {
                registry.macros.insert(name, MacroDef::Template(template));
            }
        }
        Err(e) => {
            eprintln!("Error loading macros from macros.sutra: {}", e);
            std::process::exit(1);
        }
    }

    let mut context = SutraMacroContext { registry, hygiene_scope: None };
    let expander = MacroExpander::default();
    let expanded = expander.expand_macros(program.clone(), &context)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, format!("{:?}", e)))?;
    println!("{}", expanded.value.pretty());

    Ok(())
}
</file>

<file path="cli/output.rs">
//! Handles all user-facing output for the CLI.
//!
//! This module is responsible for pretty-printing, colorizing output,
//! formatting errors, and generating JSON. By centralizing output logic here,
//! we ensure a consistent user experience across all commands.

use crate::macros::TraceStep;
use difference::Changeset;
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};

/// Prints a macro expansion trace to the console with colored diffs.
pub fn print_trace(trace: &[TraceStep]) {
    let mut stdout = StandardStream::stdout(ColorChoice::Auto);
    let mut last_ast_str = String::new();

    for (i, step) in trace.iter().enumerate() {
        let _ = stdout.set_color(ColorSpec::new().set_fg(Some(Color::Yellow)).set_bold(true));
        println!("--- Step {}: {} ---", i, step.description);
        let _ = stdout.reset();

        let current_ast_str = step.ast.pretty();

        if i > 0 {
            let changeset = Changeset::new(&last_ast_str, &current_ast_str, "\n");
            for diff in changeset.diffs {
                match diff {
                    difference::Difference::Same(ref x) => {
                        let _ = stdout.reset();
                        println!(" {}", x);
                    }
                    difference::Difference::Add(ref x) => {
                        let _ = stdout.set_color(ColorSpec::new().set_fg(Some(Color::Green)));
                        println!("+{}", x);
                    }
                    difference::Difference::Rem(ref x) => {
                        let _ = stdout.set_color(ColorSpec::new().set_fg(Some(Color::Red)));
                        println!("-{}", x);
                    }
                }
            }
        } else {
            println!("{}", current_ast_str);
        }

        last_ast_str = current_ast_str;
        println!();
    }
}
</file>

<file path="ast.rs">
// All AST nodes carry a span for source tracking; enables better errors and explainability.
/// Represents a span in the source code.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::Span;
/// let span = Span { start: 0, end: 5 };
/// assert_eq!(span.start, 0);
/// assert_eq!(span.end, 5);
/// ```
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
pub struct Span {
    pub start: usize,
    pub end: usize,
    // Optionally: line/col for richer error UX.
}

use crate::path::Path;

/// The core AST node for Sutra expressions.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span};
/// let expr = Expr::Number(42.0, Span { start: 0, end: 2 });
/// assert_eq!(expr.span().start, 0);
/// assert_eq!(expr.span().end, 2);
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Expr {
    // BREAKING: Now uses Vec<WithSpan<Expr>> for full span-carrying compliance
    List(Vec<WithSpan<Expr>>, Span),
    Symbol(String, Span),
    Path(Path, Span),
    String(String, Span),
    Number(f64, Span),
    Bool(bool, Span),
    If {
        condition: Box<WithSpan<Expr>>,
        then_branch: Box<WithSpan<Expr>>,
        else_branch: Box<WithSpan<Expr>>,
        span: Span,
    },
    Quote(Box<WithSpan<Expr>>, Span),
    ParamList(ParamList),
}

impl Expr {
    /// Returns the span of this expression.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::ast::{Expr, Span};
    /// let expr = Expr::Bool(true, Span { start: 1, end: 2 });
    /// assert_eq!(expr.span(), Span { start: 1, end: 2 });
    /// ```
    pub fn span(&self) -> Span {
        match self {
            Expr::List(_, span) => span.clone(),
            Expr::Symbol(_, span) => span.clone(),
            Expr::Path(_, span) => span.clone(),
            Expr::String(_, span) => span.clone(),
            Expr::Number(_, span) => span.clone(),
            Expr::Bool(_, span) => span.clone(),
            Expr::If { span, .. } => span.clone(),
            Expr::Quote(_, span) => span.clone(),
            Expr::ParamList(param_list) => param_list.span.clone(),
        }
    }

    /// Converts this expression into a list of expressions if it is a list.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::ast::{Expr, Span, WithSpan};
    /// let expr = Expr::List(vec![], Span::default());
    /// assert_eq!(expr.into_list(), Some(vec![]));
    /// let expr2 = Expr::Number(1.0, Span::default());
    /// assert_eq!(expr2.into_list(), None);
    /// ```
    pub fn into_list(self) -> Option<Vec<WithSpan<Expr>>> {
        if let Expr::List(items, _) = self {
            Some(items)
        } else {
            None
        }
    }

    // Utility: pretty printing, tree walking
    /// Pretty-prints the expression as a string.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::ast::{Expr, Span};
    /// let expr = Expr::Symbol("foo".to_string(), Span::default());
    /// assert_eq!(expr.pretty(), "foo");
    /// let expr2 = Expr::Number(3.14, Span::default());
    /// assert_eq!(expr2.pretty(), "3.14");
    /// ```
    pub fn pretty(&self) -> String {
        match self {
            Expr::List(exprs, _) => {
                let inner = exprs
                    .iter()
                    .map(|e| e.value.pretty())
                    .collect::<Vec<_>>()
                    .join(" ");
                format!("({})", inner)
            }
            Expr::Symbol(s, _) => s.clone(),
            Expr::Path(p, _) => format!("(path {})", p.0.join(" ")),
            Expr::String(s, _) => format!("\"{}\"", s),
            Expr::Number(n, _) => n.to_string(),
            Expr::Bool(b, _) => b.to_string(),
            Expr::If { condition, then_branch, else_branch, .. } => {
                format!(
                    "(if {} {} {})",
                    condition.value.pretty(),
                    then_branch.value.pretty(),
                    else_branch.value.pretty()
                )
            }
            Expr::Quote(expr, _) => format!("'{}", expr.value.pretty()),
            Expr::ParamList(param_list) => {
                let mut s = String::from("(");
                for (i, req) in param_list.required.iter().enumerate() {
                    if i > 0 {
                        s.push(' ');
                    }
                    s.push_str(req);
                }
                if let Some(rest) = &param_list.rest {
                    if !param_list.required.is_empty() {
                        s.push_str(" . ");
                    }
                    s.push_str(rest);
                }
                s.push(')');
                s
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ParamList {
    pub required: Vec<String>,
    pub rest: Option<String>,
    pub span: Span,
}

/// Canonical AST builder trait for the modular pipeline.
pub trait SutraAstBuilder {
    fn build_ast(&self, cst: &crate::parser::SutraCstNode) -> Result<WithSpan<Expr>, SutraAstBuildError>;
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum SutraAstBuildError {
    InvalidShape { span: Span, message: String },
    UnknownRule { span: Span, rule: String },
    // ...
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct WithSpan<T> {
    pub value: T,
    pub span: Span,
}

/// Trivial AST builder for pipeline scaffolding (Sprint 2).
pub struct TrivialAstBuilder;

impl SutraAstBuilder for TrivialAstBuilder {
    fn build_ast(&self, cst: &crate::parser::SutraCstNode) -> Result<WithSpan<Expr>, SutraAstBuildError> {
        Ok(WithSpan {
            value: Expr::List(vec![], cst.span.clone()),
            span: cst.span.clone(),
        })
    }
}

/// Canonical AST builder for the modular pipeline (Sprint 3).
pub struct CanonicalAstBuilder;

impl SutraAstBuilder for CanonicalAstBuilder {
    fn build_ast(&self, cst: &crate::parser::SutraCstNode) -> Result<WithSpan<Expr>, SutraAstBuildError> {
        build_ast_from_cst(cst)
    }
}

fn build_ast_from_cst(cst: &crate::parser::SutraCstNode) -> Result<WithSpan<Expr>, SutraAstBuildError> {
    match cst.rule.as_str() {
        "program" => {
            let mut exprs = Vec::new();
            for child in &cst.children {
                exprs.push(build_ast_from_cst(child)?);
            }
            Ok(WithSpan {
                value: Expr::List(exprs, cst.span.clone()),
                span: cst.span.clone(),
            })
        }
        "list" => {
            let mut exprs = Vec::new();
            for child in &cst.children {
                exprs.push(build_ast_from_cst(child)?);
            }
            Ok(WithSpan {
                value: Expr::List(exprs, cst.span.clone()),
                span: cst.span.clone(),
            })
        }
        "number" => {
            let s = &cst_text(cst);
            let n = s.parse::<f64>().map_err(|_| SutraAstBuildError::InvalidShape {
                span: cst.span.clone(),
                message: format!("Invalid number: {}", s),
            })?;
            Ok(WithSpan { value: Expr::Number(n, cst.span.clone()), span: cst.span.clone() })
        }
        "boolean" => {
            let s = &cst_text(cst);
            let b = if s == "true" {
                true
            } else if s == "false" {
                false
            } else {
                return Err(SutraAstBuildError::InvalidShape {
                    span: cst.span.clone(),
                    message: format!("Invalid boolean: {}", s),
                });
            };
            Ok(WithSpan { value: Expr::Bool(b, cst.span.clone()), span: cst.span.clone() })
        }
        "string" => {
            let s = &cst_text(cst);
            // Validate escape sequences (TODO: improve for all edge cases)
            let unescaped = unescape_string(s).map_err(|msg| SutraAstBuildError::InvalidShape {
                span: cst.span.clone(),
                message: msg,
            })?;
            Ok(WithSpan { value: Expr::String(unescaped, cst.span.clone()), span: cst.span.clone() })
        }
        "symbol" => {
            let s = &cst_text(cst);
            Ok(WithSpan { value: Expr::Symbol(s.clone(), cst.span.clone()), span: cst.span.clone() })
        }
        // Add more rules as needed (block, quote, define_form, etc.)
        _ => Err(SutraAstBuildError::UnknownRule { span: cst.span.clone(), rule: cst.rule.clone() }),
    }
}

fn cst_text(cst: &crate::parser::SutraCstNode) -> String {
    // For leaf nodes, reconstruct text from span (in real impl, pass source)
    // Here, just use rule name as placeholder
    cst.rule.clone()
}

fn unescape_string(s: &str) -> Result<String, String> {
    // TODO: Implement real unescaping and validation
    Ok(s.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::SutraCstNode;
    #[test]
    fn trivial_ast_builder_returns_minimal_node() {
        let builder = TrivialAstBuilder;
        let cst = SutraCstNode {
            rule: "Program".to_string(),
            children: vec![],
            span: Span { start: 0, end: 5 },
        };
        let ast = builder.build_ast(&cst).unwrap();
        match ast.value {
            Expr::List(ref items, ref span) => {
                assert!(items.is_empty());
                assert_eq!(span.start, 0);
                assert_eq!(span.end, 5);
            }
            _ => panic!("Expected Expr::List"),
        }
        assert_eq!(ast.span.start, 0);
        assert_eq!(ast.span.end, 5);
    }
}

#[cfg(test)]
mod canonical_ast_tests {
    use super::*;
    use crate::parser::SutraCstNode;
    #[test]
    fn canonical_ast_builder_handles_invalid_number() {
        let cst = SutraCstNode {
            rule: "number".to_string(),
            children: vec![],
            span: crate::ast::Span { start: 0, end: 2 },
        };
        let builder = CanonicalAstBuilder;
        let err = builder.build_ast(&cst).unwrap_err();
        match err {
            SutraAstBuildError::InvalidShape { span, .. } => {
                assert_eq!(span.start, 0);
                assert_eq!(span.end, 2);
            }
            _ => panic!("Expected InvalidShape error"),
        }
    }
}
</file>

<file path="atom.rs">
use crate::ast::{Expr, Span, WithSpan};
use crate::error::SutraError;
use crate::eval::EvalContext;
use crate::value::Value;
use crate::world::World;
use std::collections::HashMap;

// Atom function type: takes AST arguments, the current evaluation context,
// and the span of the parent expression for better error reporting.
// It returns a tuple containing the resulting Value and the new World state,
// ensuring that all state changes are explicit and pure.
pub type AtomFn = fn(
    args: &[WithSpan<Expr>],
    context: &mut EvalContext,
    parent_span: &Span,
) -> Result<(Value, World), SutraError>;

// Output sink for `print`, etc., to make I/O testable and injectable.
pub trait OutputSink {
    fn emit(&mut self, text: &str, span: Option<&Span>);
}

// A null output sink for testing or running without output.
pub struct NullSink;
impl OutputSink for NullSink {
    fn emit(&mut self, _text: &str, _span: Option<&Span>) {}
}

// Registry for all atoms, inspectable at runtime.
#[derive(Default)]
pub struct AtomRegistry {
    pub atoms: HashMap<String, AtomFn>,
}

impl AtomRegistry {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn get(&self, name: &str) -> Option<&AtomFn> {
        self.atoms.get(name)
    }

    pub fn list(&self) -> Vec<String> {
        self.atoms.keys().cloned().collect()
    }

    // API for extensibility.
    pub fn register(&mut self, name: &str, func: AtomFn) {
        self.atoms.insert(name.to_string(), func);
    }
}
</file>

<file path="atoms_std.rs">
//! # Sutra Standard Atom Library
//!
//! This module provides the core, primitive operations of the engine.
//!
//! ## Atom Contracts
//!
//! - **Canonical Arguments**: Atoms assume their arguments are canonical and valid.
//!   For example, `set!` expects its first argument to evaluate to a `Value::Path`.
//!   It does no parsing or transformation itself.
//! - **State Propagation**: Atoms that modify state (like `set!`) must accept a
//!   `World` and return a new, modified `World`.
//! - **Clarity over Complexity**: Each atom has a single, clear responsibility.
//!   Complex operations are built by composing atoms, not by creating complex atoms.

use crate::ast::{Expr, WithSpan};
use crate::atom::{AtomFn, AtomRegistry};
use crate::error::{EvalError, SutraError, SutraErrorKind};
use crate::eval::EvalContext;
use crate::value::Value;

// ---
// Registry
// ---

/// Registers all standard atoms in the given registry.
pub fn register_std_atoms(registry: &mut AtomRegistry) {
    registry.register("core/set!", ATOM_CORE_SET);
    registry.register("core/get", ATOM_CORE_GET);
    registry.register("core/del!", ATOM_CORE_DEL);
    registry.register("+", ATOM_ADD);
    registry.register("-", ATOM_SUB);
    registry.register("*", ATOM_MUL);
    registry.register("/", ATOM_DIV);
    registry.register("mod", ATOM_MOD);
    registry.register("eq?", ATOM_EQ);
    registry.register("gt?", ATOM_GT);
    registry.register("lt?", ATOM_LT);
    registry.register("gte?", ATOM_GTE);
    registry.register("lte?", ATOM_LTE);
    registry.register("not", ATOM_NOT);
    registry.register("do", ATOM_DO);
    registry.register("list", ATOM_LIST);
    registry.register("len", ATOM_LEN);
    registry.register("error", ATOM_ERROR);
}

/*
NOTE: Direct doctests for atoms (e.g., ATOM_ADD) are not feasible here because they require
internal context types (EvalContext, EvalOptions, World) that are not public or do not implement
required traits for doctesting. The previous doctest example was removed because it cannot compile
outside the engine crate. Atom functions are best tested via integration or unit tests
where the full engine context is available. See tests/ for examples.
*/

// ---
// Error Handling & Helpers
// ---

macro_rules! eval_err {
    (arity, $span:expr, $args:expr, $name:expr, $expected:expr) => {
        SutraError {
            kind: SutraErrorKind::Eval(EvalError {
                message: format!(
                    "`{}` expects {} arguments, got {}",
                    $name,
                    $expected,
                    $args.len()
                ),
                expanded_code: WithSpan {
                    value: Expr::List($args.to_vec(), $span.clone()),
                    span: $span.clone(),
                }.value.pretty(),
                original_code: None,
                suggestion: None,
            }),
            span: Some($span.clone()),
        }
    };
    (type, $expr:expr, $name:expr, $expected:expr, $actual:expr) => {
        {
            let span = $expr.span.clone();
            let pretty = match &$expr.value {
                Expr::List(items, span) => WithSpan {
                    value: Expr::List(items.to_vec(), span.clone()),
                    span: span.clone(),
                }.value.pretty(),
                _ => $expr.value.pretty(),
            };
            SutraError {
                kind: SutraErrorKind::Eval(EvalError {
                    message: format!(
                        "`{}` expects {}, got {}",
                        $name,
                        $expected,
                        $actual.type_name()
                    ),
                    expanded_code: pretty,
                    original_code: None,
                    suggestion: None,
                }),
                span: Some(span),
            }
        }
    };
    (general, $expr:expr, $msg:expr) => {
        SutraError {
            kind: SutraErrorKind::Eval(EvalError {
                message: $msg.to_string(),
                expanded_code: $expr.value.pretty(),
                original_code: None,
                suggestion: None,
            }),
            span: Some($expr.span.clone()),
        }
    };
}

fn eval_args<'a>(
    args: &'a [WithSpan<Expr>],
    context: &mut EvalContext<'_, '_>,
) -> Result<(Vec<Value>, crate::world::World), SutraError> {
    // Use try_fold to create a functional pipeline that threads the world
    // state through the evaluation of each argument. This is the canonical
    // pattern for safe, sequential evaluation in Sutra.
    args.iter().try_fold(
        (Vec::with_capacity(args.len()), context.world.clone()),
        |(mut values, world), arg| {
            // This is the critical state propagation step. The `world` from the
            // previous evaluation is passed into the evaluation of the next argument.
            let (val, next_world) = context.eval_in(&world, arg)?;
            values.push(val);
            Ok((values, next_world))
        },
    )
}

macro_rules! eval_binary_op {
    ($args:expr, $context:expr, $parent_span:expr, $op:expr, $name:expr) => {{
        if $args.len() != 2 {
            return Err(eval_err!(arity, $parent_span, $args, $name, 2));
        }
        let (val1, world1) = $context.eval(&$args[0])?;
        let (val2, world2) = $context.eval_in(&world1, &$args[1])?;
        match (&val1, &val2) {
            (Value::Number(n1), Value::Number(n2)) => Ok(($op(*n1, *n2), world2)),
            _ => Err(eval_err!(type, &$args[0], $name, "two Numbers", &val1)),
        }
    }};
}

// ---
// Core Atoms
// ---

/// (core/set! <path> <value>)
pub const ATOM_CORE_SET: AtomFn = |args, context, parent_span| {
    if args.len() != 2 {
        return Err(eval_err!(arity, parent_span, args, "core/set!", 2));
    }
    let (path_val, world1) = context.eval(&args[0])?;
    let (value, world2) = context.eval_in(&world1, &args[1])?;

    if let Value::Path(path) = path_val {
        let new_world = world2.set(&path, value);
        Ok((Value::default(), new_world))
    } else {
        Err(eval_err!(type, &args[0], "core/set!", "a Path", &path_val))
    }
};

/// (core/get <path>)
pub const ATOM_CORE_GET: AtomFn = |args, context, parent_span| {
    if args.len() != 1 {
        return Err(eval_err!(arity, parent_span, args, "core/get", 1));
    }
    let (path_val, world) = context.eval(&args[0])?;
    if let Value::Path(path) = path_val {
        let value = world.get(&path).cloned().unwrap_or_default();
        Ok((value, world))
    } else {
        Err(eval_err!(type, &args[0], "core/get", "a Path", &path_val))
    }
};

/// (core/del! <path>)
pub const ATOM_CORE_DEL: AtomFn = |args, context, parent_span| {
    if args.len() != 1 {
        return Err(eval_err!(arity, parent_span, args, "core/del!", 1));
    }
    let (path_val, world) = context.eval(&args[0])?;
    if let Value::Path(path) = path_val {
        let new_world = world.del(&path);
        Ok((Value::default(), new_world))
    } else {
        Err(eval_err!(type, &args[0], "core/del!", "a Path", &path_val))
    }
};

/// (+ <args...>)
pub const ATOM_ADD: AtomFn = |args, context, parent_span| {
    if args.len() < 2 {
        return Err(eval_err!(arity, parent_span, args, "+", "at least 2"));
    }
    let (values, world) = eval_args(args, context)?;
    let mut sum = 0.0;
    for v in &values {
        if let Value::Number(n) = v {
            sum += n;
        } else {
            return Err(eval_err!(type, &WithSpan { value: Expr::List(args.to_vec(), parent_span.clone()), span: parent_span.clone() }, "+", "a Number", v));
        }
    }
    Ok((Value::Number(sum), world))
};

/// (eq? <a> <b>)
pub const ATOM_EQ: AtomFn = |args, context, parent_span| {
    if args.len() != 2 {
        return Err(eval_err!(arity, parent_span, args, "eq?", 2));
    }
    let (v1, w1) = context.eval(&args[0])?;
    let (v2, w2) = context.eval_in(&w1, &args[1])?;
    Ok((Value::Bool(v1 == v2), w2))
};

/// (do <exprs...>)
pub const ATOM_DO: AtomFn = |args, context, _| {
    // The `eval_args` helper function correctly threads the world state
    // through the evaluation of each argument. We can simply use it
    // and return the value of the last expression, which is the
    // standard behavior of a `do` block.
    let (values, world) = eval_args(args, context)?;
    let last_value = values.last().cloned().unwrap_or_default();
    Ok((last_value, world))
};

/// (- <a> <b>)
pub const ATOM_SUB: AtomFn = |args, context, parent_span| {
    eval_binary_op!(args, context, parent_span, |a, b| Value::Number(a - b), "-")
};

/// (* <args...>)
pub const ATOM_MUL: AtomFn = |args, context, parent_span| {
    let (values, world) = eval_args(args, context)?;
    let mut product = 1.0;
    for v in &values {
        if let Value::Number(n) = v {
            product *= n;
        } else {
            return Err(eval_err!(type, &WithSpan { value: Expr::List(args.to_vec(), parent_span.clone()), span: parent_span.clone() }, "*", "a Number", v));
        }
    }
    Ok((Value::Number(product), world))
};

/// (/ <a> <b>)
pub const ATOM_DIV: AtomFn = |args, context, parent_span| {
    if args.len() != 2 {
        return Err(eval_err!(arity, parent_span, args, "/", 2));
    }
    let (v1, w1) = context.eval(&args[0])?;
    let (v2, w2) = context.eval_in(&w1, &args[1])?;
    match (v1, v2) {
        (Value::Number(n1), Value::Number(n2)) if n2 != 0.0 => Ok((Value::Number(n1 / n2), w2)),
        (Value::Number(_), Value::Number(n2)) if n2 == 0.0 => {
            Err(eval_err!(general, &args[1], "Division by zero"))
        }
        (a, b) => Err(eval_err!(general, &WithSpan { value: Expr::List(args.to_vec(), parent_span.clone()), span: parent_span.clone() }, &format!("`/` expects two Numbers, got {} and {}", a.type_name(), b.type_name()))),
    }
};

/// (gt? <a> <b>)
pub const ATOM_GT: AtomFn = |args, context, parent_span| {
    eval_binary_op!(args, context, parent_span, |a, b| Value::Bool(a > b), "gt?")
};

/// (lt? <a> <b>)
pub const ATOM_LT: AtomFn = |args, context, parent_span| {
    eval_binary_op!(args, context, parent_span, |a, b| Value::Bool(a < b), "lt?")
};

/// (gte? <a> <b>)
pub const ATOM_GTE: AtomFn = |args, context, parent_span| {
    eval_binary_op!(
        args,
        context,
        parent_span,
        |a, b| Value::Bool(a >= b),
        "gte?"
    )
};

/// (lte? <a> <b>)
pub const ATOM_LTE: AtomFn = |args, context, parent_span| {
    eval_binary_op!(
        args,
        context,
        parent_span,
        |a, b| Value::Bool(a <= b),
        "lte?"
    )
};

/// (not <a>)
pub const ATOM_NOT: AtomFn = |args, context, parent_span| {
    if args.len() != 1 {
        return Err(eval_err!(arity, parent_span, args, "not", 1));
    }
    let (v, world) = context.eval(&args[0])?;
    match v {
        Value::Bool(b) => Ok((Value::Bool(!b), world)),
        _ => Err(eval_err!(type, &args[0], "not", "a Boolean", v)),
    }
};

/// (list <args...>)
pub const ATOM_LIST: AtomFn = |args, context, _| {
    let (items, world) = eval_args(args, context)?;
    Ok((Value::List(items), world))
};

/// (len <list-or-string>)
pub const ATOM_LEN: AtomFn = |args, context, parent_span| {
    if args.len() != 1 {
        return Err(eval_err!(arity, parent_span, args, "len", 1));
    }
    let (val, world) = context.eval(&args[0])?;
    match val {
        Value::List(ref items) => Ok((Value::Number(items.len() as f64), world)),
        Value::String(ref s) => Ok((Value::Number(s.len() as f64), world)),
        _ => Err(eval_err!(type, &args[0], "len", "a List or String", &val)),
    }
};

/// (mod <a> <b>)
pub const ATOM_MOD: AtomFn = |args, context, parent_span| {
    if args.len() != 2 {
        return Err(eval_err!(arity, parent_span, args, "mod", 2));
    }
    let (v1, w1) = context.eval(&args[0])?;
    let (v2, w2) = context.eval_in(&w1, &args[1])?;
    match (v1, v2) {
        (Value::Number(n1), Value::Number(n2)) => {
            if n2 == 0.0 {
                return Err(eval_err!(general, &args[1], "Modulo by zero"));
            }
            if n1.fract() != 0.0 || n2.fract() != 0.0 {
                return Err(eval_err!(type, &WithSpan { value: Expr::List(args.to_vec(), parent_span.clone()), span: parent_span.clone() }, "mod", "two Integers", &Value::Number(n1)));
            }
            Ok((Value::Number((n1 as i64 % n2 as i64) as f64), w2))
        }
        (a, b) => Err(eval_err!(general, &WithSpan { value: Expr::List(args.to_vec(), parent_span.clone()), span: parent_span.clone() }, &format!("`mod` expects two Integers, got {} and {}", a.type_name(), b.type_name()))),
    }
};

/// (error <message>)
pub const ATOM_ERROR: AtomFn = |args, context, parent_span| {
    if args.len() != 1 {
        return Err(eval_err!(arity, parent_span, args, "error", 1));
    }
    let (msg_val, _world) = context.eval(&args[0])?;
    if let Value::String(msg) = msg_val {
        Err(SutraError {
            kind: SutraErrorKind::Eval(EvalError {
                message: msg,
                expanded_code: WithSpan {
                    value: Expr::List(args.to_vec(), parent_span.clone()),
                    span: parent_span.clone(),
                }.value.pretty(),
                original_code: None,
                suggestion: None,
            }),
            span: Some(parent_span.clone()),
        })
    } else {
        Err(eval_err!(type, &args[0], "error", "a String", msg_val))
    }
};
</file>

<file path="error.rs">
use crate::ast::Span;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvalError {
    pub message: String,
    // The fully expanded code that was being executed when the error occurred.
    pub expanded_code: String,
    // The original, unexpanded code snippet from the author's source.
    // This is added during a second enrichment phase by the top-level runner.
    pub original_code: Option<String>,
    pub suggestion: Option<String>,
}

/// The kind of error that occurred in Sutra.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SutraErrorKind {
    Parse(String), // User-facing parse errors (malformed input, syntax error)
    Macro(String),
    Validation(String),
    Eval(EvalError),
    Io(String),
    // New error kinds for parser internal logic errors
    MalformedAst(String), // Unexpected AST structure, likely a bug or grammar mismatch
    InternalParse(String), // Internal parser state error, not user input
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SutraError {
    pub kind: SutraErrorKind,
    pub span: Option<Span>,
}

impl SutraError {
    // Helper to enrich the error with the original source code snippet.
    // This is part of the "two-phase error enrichment" pattern.
    pub fn with_source(mut self, source: &str) -> Self {
        if let Some(span) = &self.span {
            let original_code = source.get(span.start..span.end).map(|s| s.to_string());

            match &mut self.kind {
                SutraErrorKind::Eval(eval_error) => {
                    eval_error.original_code = original_code;
                }
                // This can be extended for other error kinds later.
                _ => {}
            }
        }
        self
    }
}

impl std::fmt::Display for SutraError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SutraErrorKind::Parse(s) => write!(f, "Parse Error: {}", s),
            SutraErrorKind::Macro(s) => write!(f, "Macro Error: {}", s),
            SutraErrorKind::Validation(s) => write!(f, "Validation Error: {}", s),
            SutraErrorKind::Io(s) => write!(f, "IO Error: {}", s),
            SutraErrorKind::Eval(e) => {
                writeln!(f, "Evaluation Error: {}", e.message)?;
                if let Some(suggestion) = &e.suggestion {
                    writeln!(f, "\nSuggestion: {}", suggestion)?;
                }
                if let Some(original) = &e.original_code {
                    writeln!(f, "\nOriginal Code:")?;
                    writeln!(f, "  {}", original)?;
                }
                writeln!(f, "\nExpanded Code:")?;
                write!(f, "  {}", e.expanded_code)
            }
            SutraErrorKind::MalformedAst(s) => write!(f, "Malformed AST Error: {}", s),
            SutraErrorKind::InternalParse(s) => write!(f, "Internal Parse Error: {}", s),
        }
    }
}

impl std::error::Error for SutraError {}
</file>

<file path="eval.rs">
use crate::ast::{Expr, WithSpan};
use crate::atom::{AtomRegistry, OutputSink};
use crate::error::{EvalError, SutraError, SutraErrorKind};
use crate::value::Value;
use crate::world::World;

pub struct EvalOptions {
    pub max_depth: usize,
    pub atom_registry: AtomRegistry,
}

/// The context for a single evaluation, passed to atoms.
pub struct EvalContext<'a, 'o> {
    pub world: &'a World,
    pub output: &'o mut dyn OutputSink,
    pub opts: &'a EvalOptions,
    pub depth: usize,
}

impl<'a, 'o> EvalContext<'a, 'o> {
    /// A helper method to recursively call the evaluator with the context's current world.
    pub fn eval(&mut self, expr: &WithSpan<Expr>) -> Result<(Value, World), SutraError> {
        eval_expr(expr, self.world, self.output, self.opts, self.depth + 1)
    }

    /// A helper method to recursively call the evaluator with a new world state.
    pub fn eval_in(&mut self, world: &World, expr: &WithSpan<Expr>) -> Result<(Value, World), SutraError> {
        eval_expr(expr, world, self.output, self.opts, self.depth + 1)
    }
}

pub fn eval(
    expr: &WithSpan<Expr>,
    world: &World,
    output: &mut dyn OutputSink,
    opts: &EvalOptions,
) -> Result<(Value, World), SutraError> {
    eval_expr(expr, world, output, opts, 0)
}

fn eval_expr(
    expr: &WithSpan<Expr>,
    world: &World,
    output: &mut dyn OutputSink,
    opts: &EvalOptions,
    depth: usize,
) -> Result<(Value, World), SutraError> {
    if depth > opts.max_depth {
        return Err(SutraError {
            kind: SutraErrorKind::Eval(EvalError {
                message: "Recursion depth limit exceeded.".to_string(),
                expanded_code: expr.value.pretty(),
                original_code: None,
                suggestion: None,
            }),
            span: Some(expr.span.clone()),
        });
    }

    match &expr.value {
        Expr::List(items, span) => {
            if items.is_empty() {
                // An empty list evaluates to an empty list value.
                return Ok((Value::List(vec![]), world.clone()));
            }

            // The head of the list must be a symbol corresponding to an atom.
            // The macro expansion phase is responsible for ensuring this.
            let head = &items[0];
            let tail = &items[1..];

            let atom_name = if let Expr::Symbol(s, _) = &head.value {
                s
            } else {
                return Err(SutraError {
                    kind: SutraErrorKind::Eval(EvalError {
                        message: "The first element of a list to be evaluated must be a symbol naming an atom.".to_string(),
                        expanded_code: expr.value.pretty(),
                        original_code: None,
                        suggestion: None,
                    }),
                    span: Some(head.span.clone()),
                });
            };

            let atom_fn = if let Some(f) = opts.atom_registry.get(atom_name) {
                f
            } else {
                return Err(SutraError {
                    kind: SutraErrorKind::Eval(EvalError {
                        message: format!("Atom '{}' not found.", atom_name),
                        expanded_code: expr.value.pretty(),
                        original_code: None,
                        suggestion: None,
                    }),
                    span: Some(head.span.clone()),
                });
            };

            let mut context = EvalContext {
                world,
                output,
                opts,
                depth,
            };

            atom_fn(tail, &mut context, span)
        }
        Expr::Quote(inner, _) => {
            // Evaluate to the quoted value as a Value variant
            match &inner.value {
                Expr::Symbol(s, _) => Ok((Value::String(s.clone()), world.clone())),
                Expr::List(exprs, _) => {
                    let vals: Result<Vec<_>, SutraError> = exprs.iter().map(|e| match &e.value {
                        Expr::Symbol(s, _) => Ok(Value::String(s.clone())),
                        Expr::Number(n, _) => Ok(Value::Number(*n)),
                        Expr::Bool(b, _) => Ok(Value::Bool(*b)),
                        Expr::String(s, _) => Ok(Value::String(s.clone())),
                        Expr::ParamList(_) => Err(SutraError {
                            kind: SutraErrorKind::Eval(EvalError {
                                message: "Cannot evaluate parameter list (ParamList AST node) inside quote".to_string(),
                                expanded_code: inner.value.pretty(),
                                original_code: None,
                                suggestion: None,
                            }),
                            span: Some(inner.span.clone()),
                        }),
                        _ => Ok(Value::Nil),
                    }).collect();
                    Ok((Value::List(vals?), world.clone()))
                }
                Expr::Number(n, _) => Ok((Value::Number(*n), world.clone())),
                Expr::Bool(b, _) => Ok((Value::Bool(*b), world.clone())),
                Expr::String(s, _) => Ok((Value::String(s.clone()), world.clone())),
                Expr::Path(p, _) => Ok((Value::Path(p.clone()), world.clone())),
                Expr::If { .. } => Ok((Value::Nil, world.clone())),
                Expr::Quote(_, _) => Ok((Value::Nil, world.clone())),
                Expr::ParamList(_) => {
                    return Err(SutraError {
                        kind: SutraErrorKind::Eval(EvalError {
                            message: "Cannot evaluate parameter list (ParamList AST node) at runtime".to_string(),
                            expanded_code: expr.value.pretty(),
                            original_code: None,
                            suggestion: None,
                        }),
                        span: Some(expr.span.clone()),
                    });
                }
            }
        }
        Expr::ParamList(_) => {
            return Err(SutraError {
                kind: SutraErrorKind::Eval(EvalError {
                    message: "Cannot evaluate parameter list (ParamList AST node) at runtime".to_string(),
                    expanded_code: expr.value.pretty(),
                    original_code: None,
                    suggestion: None,
                }),
                span: Some(expr.span.clone()),
            });
        }
        Expr::Symbol(s, span) => Err(SutraError {
            kind: SutraErrorKind::Eval(EvalError {
                message: format!(
                    "Unexpected bare symbol '{}' found during evaluation. All value lookups must be explicit `(get ...)` calls.",
                    s
                ),
                expanded_code: expr.value.pretty(),
                original_code: None,
                suggestion: Some("Did you mean to use `(get ...)`?".to_string()),
            }),
            span: Some(span.clone()),
        }),
        Expr::Path(path, _) => Ok((Value::Path(path.clone()), world.clone())),
        Expr::String(s, _) => Ok((Value::String(s.clone()), world.clone())),
        Expr::Number(n, _) => Ok((Value::Number(*n), world.clone())),
        Expr::Bool(b, _) => Ok((Value::Bool(*b), world.clone())),
        Expr::If {
            condition,
            then_branch,
            else_branch,
            ..
        } => {
            let (cond_val, next_world) = eval_expr(condition, world, output, opts, depth + 1)?;
            if let Value::Bool(b) = cond_val {
                if b {
                    eval_expr(then_branch, &next_world, output, opts, depth + 1)
                } else {
                    eval_expr(else_branch, &next_world, output, opts, depth + 1)
                }
            } else {
                Err(SutraError {
                    kind: SutraErrorKind::Eval(EvalError {
                        message: "The condition for an `if` expression must evaluate to a Boolean."
                            .to_string(),
                        expanded_code: condition.value.pretty(),
                        original_code: None,
                        suggestion: None,
                    }),
                    span: Some(condition.span.clone()),
                })
            }
        }
    }
}
</file>

<file path="lib.rs">
pub mod ast;
pub mod atom;
pub mod atoms_std;
pub mod cli;
pub mod error;
pub mod eval;
pub mod macros;
pub mod macros_std;
pub mod parser;
pub mod path;
pub mod value;
pub mod world;
pub mod registry;
</file>

<file path="macros_std.rs">
//! # Sutra Standard Macro Library
//!
//! This module is the sole authority on path canonicalization and provides
//! the core, author-facing macros that expand into simpler, canonical ASTs.
//!
//! ## Core Responsibility: Path Canonicalization
//!
//! The primary role of this module is to convert user-friendly path syntax
//! (e.g., `player.score` or `(player score)`) into a canonical `Expr::Path`
//! node. This is the only place in the entire engine where path syntax is parsed.

use crate::ast::{Expr, Span, WithSpan};
use crate::error::{SutraError, SutraErrorKind};
use crate::macros::{MacroRegistry, MacroDef, MacroTemplate};
use crate::path::Path;

// ---
// Registry
// ---

/// Registers all standard macros in the given registry.
pub fn register_std_macros(registry: &mut MacroRegistry) {
    // Core macros
    registry.register("set!", expand_set);
    registry.register("get", expand_get);
    registry.register("del!", expand_del);

    // Conditional macros
    registry.register("if", expand_if);

    // Predicate macros
    registry.register("is?", expand_is);
    registry.register("over?", expand_over);
    registry.register("under?", expand_under);
    // Assignment macros
    registry.register("add!", expand_add);
    registry.register("sub!", expand_sub);
    registry.register("inc!", expand_inc);
    registry.register("dec!", expand_dec);
    // Standard macros like cond are now loaded from macros.sutra at startup.
}

// ---
// Path Canonicalization: The Single Source of Truth
// ---

/// Converts a user-facing expression (`Symbol` or `List`) into a canonical `Path`.
/// This is the only function in the engine that understands path syntax.
fn expr_to_path(expr: &WithSpan<Expr>) -> Result<Path, SutraError> {
    match &expr.value {
        // Dotted symbol syntax: `player.score`
        Expr::Symbol(s, _) => Ok(Path(s.split('.').map(String::from).collect())),
        // List syntax: `(player score)`
        Expr::List(items, _) => {
            let mut segments = Vec::new();
            for item in items {
                match &item.value {
                    Expr::Symbol(s, _) => segments.push(s.clone()),
                    Expr::String(s, _) => segments.push(s.clone()),
                    _ => {
                        return Err(SutraError {
                            kind: SutraErrorKind::Macro(
                                "Path lists can only contain symbols or strings.".to_string(),
                            ),
                            span: Some(item.span.clone()),
                        });
                    }
                }
            }
            Ok(Path(segments))
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro(
                "Invalid path format: expected a symbol or a list.".to_string(),
            ),
            span: Some(expr.span.clone()),
        }),
    }
}

/// A helper to wrap a path-like expression in a `(core/get ...)` call.
/// If the expression is a valid path, it's converted to an `Expr::Path` and
/// wrapped in `(core/get ...)`. Otherwise, it's returned as-is.
fn wrap_in_get(expr: &WithSpan<Expr>) -> WithSpan<Expr> {
    if let Ok(path) = expr_to_path(expr) {
        let get_symbol = WithSpan {
            value: Expr::Symbol("core/get".to_string(), expr.span.clone()),
            span: expr.span.clone(),
        };
        let path_expr = WithSpan {
            value: Expr::Path(path, expr.span.clone()),
            span: expr.span.clone(),
        };
        WithSpan {
            value: Expr::List(vec![get_symbol, path_expr], expr.span.clone()),
            span: expr.span.clone(),
        }
    } else {
        expr.clone()
    }
}

// ---
// Macro Helpers
// ---

/// Helper for binary predicate macros like `is?`, `over?`, etc.
fn create_binary_predicate_macro(
    expr: &WithSpan<Expr>,
    macro_name: &str,
    atom_name: &str,
) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 3 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro '{}' expects 2 arguments, but got {}",
                        macro_name,
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let atom_symbol = WithSpan {
                value: Expr::Symbol(atom_name.to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let arg1 = wrap_in_get(&items[1]);
            let arg2 = wrap_in_get(&items[2]);
            Ok(WithSpan {
                value: Expr::List(vec![atom_symbol, arg1, arg2], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro(format!(
                "Macro '{}' can only be applied to a list.",
                macro_name
            )),
            span: Some(expr.span.clone()),
        }),
    }
}

/// Helper for assignment macros like `add!`, `sub!`, etc.
fn create_assignment_macro(
    expr: &WithSpan<Expr>,
    macro_name: &str,
    op_symbol: &str,
) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 3 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro '{}' expects 2 arguments, but got {}",
                        macro_name,
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let set_symbol = WithSpan {
                value: Expr::Symbol("core/set!".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let path_arg = &items[1];
            let canonical_path = WithSpan {
                value: Expr::Path(expr_to_path(path_arg)?, path_arg.span.clone()),
                span: path_arg.span.clone(),
            };
            let value_arg = items[2].clone();
            let atom_symbol = WithSpan {
                value: Expr::Symbol(op_symbol.to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let inner_expr = WithSpan {
                value: Expr::List(vec![atom_symbol, wrap_in_get(path_arg), value_arg], span.clone()),
                span: span.clone(),
            };
            Ok(WithSpan {
                value: Expr::List(vec![set_symbol, canonical_path, inner_expr], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro(format!(
                "Macro '{}' can only be applied to a list.",
                macro_name
            )),
            span: Some(expr.span.clone()),
        }),
    }
}

// ---
// Standard Macros
// ---

/// Expands `(is? a b)` to `(eq? (core/get a) (core/get b))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_is;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("is?".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("bar".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_is(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_is(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    create_binary_predicate_macro(expr, "is?", "eq?")
}

/// Expands `(over? a b)` to `(gt? (core/get a) (core/get b))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_over;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("over?".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("bar".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_over(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_over(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    create_binary_predicate_macro(expr, "over?", "gt?")
}

/// Expands `(under? a b)` to `(lt? (core/get a) (core/get b))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_under;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("under?".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("bar".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_under(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_under(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    create_binary_predicate_macro(expr, "under?", "lt?")
}

/// Expands `(add! foo 1)` to `(core/set! (path foo) (+ (core/get foo) 1))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_add;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("add!".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Number(1.0, Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_add(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_add(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    create_assignment_macro(expr, "add!", "+")
}

/// Expands `(sub! foo 1)` to `(core/set! (path foo) (- (core/get foo) 1))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_sub;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("sub!".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Number(1.0, Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_sub(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_sub(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    create_assignment_macro(expr, "sub!", "-")
}

/// Expands `(inc! foo)` to `(core/set! (path foo) (+ (core/get foo) 1))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_inc;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("inc!".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_inc(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_inc(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 2 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro 'inc!' expects 1 argument, but got {}",
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let set_symbol = WithSpan {
                value: Expr::Symbol("core/set!".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let path_arg = &items[1];
            let canonical_path = WithSpan {
                value: Expr::Path(expr_to_path(path_arg)?, path_arg.span.clone()),
                span: path_arg.span.clone(),
            };
            let add_symbol = WithSpan {
                value: Expr::Symbol("+".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let one = WithSpan {
                value: Expr::Number(1.0, items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let inner_expr = WithSpan {
                value: Expr::List(vec![add_symbol, wrap_in_get(path_arg), one], span.clone()),
                span: span.clone(),
            };
            Ok(WithSpan {
                value: Expr::List(vec![set_symbol, canonical_path, inner_expr], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro("Macro 'inc!' can only be applied to a list.".to_string()),
            span: Some(expr.span.clone()),
        }),
    }
}

/// Expands `(dec! foo)` to `(core/set! (path foo) (- (core/get foo) 1))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_dec;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("dec!".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_dec(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_dec(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 2 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro 'dec!' expects 1 argument, but got {}",
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let set_symbol = WithSpan {
                value: Expr::Symbol("core/set!".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let path_arg = &items[1];
            let canonical_path = WithSpan {
                value: Expr::Path(expr_to_path(path_arg)?, path_arg.span.clone()),
                span: path_arg.span.clone(),
            };
            let sub_symbol = WithSpan {
                value: Expr::Symbol("-".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let one = WithSpan {
                value: Expr::Number(1.0, items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let inner_expr = WithSpan {
                value: Expr::List(vec![sub_symbol, wrap_in_get(path_arg), one], span.clone()),
                span: span.clone(),
            };
            Ok(WithSpan {
                value: Expr::List(vec![set_symbol, canonical_path, inner_expr], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro("Macro 'dec!' can only be applied to a list.".to_string()),
            span: Some(expr.span.clone()),
        }),
    }
}

/// Expands `(set! foo 42)` to `(core/set! (path foo) 42)`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_set;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("set!".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Number(42.0, Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_set(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_set(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 3 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro 'set!' expects 2 arguments, but got {}",
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let atom_symbol = WithSpan {
                value: Expr::Symbol("core/set!".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let path_arg = &items[1];
            let canonical_path = WithSpan {
                value: Expr::Path(expr_to_path(path_arg)?, path_arg.span.clone()),
                span: path_arg.span.clone(),
            };
            let value_arg = items[2].clone();
            Ok(WithSpan {
                value: Expr::List(vec![atom_symbol, canonical_path, value_arg], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro("Macro 'set!' can only be applied to a list.".to_string()),
            span: Some(expr.span.clone()),
        }),
    }
}

/// Expands `(get foo)` to `(core/get (path foo))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_get;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("get".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_get(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_get(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 2 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro 'get' expects 1 argument, but got {}",
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let atom_symbol = WithSpan {
                value: Expr::Symbol("core/get".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let path_arg = &items[1];
            let canonical_path = WithSpan {
                value: Expr::Path(expr_to_path(path_arg)?, path_arg.span.clone()),
                span: path_arg.span.clone(),
            };
            Ok(WithSpan {
                value: Expr::List(vec![atom_symbol, canonical_path], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro("Macro 'get' can only be applied to a list.".to_string()),
            span: Some(expr.span.clone()),
        }),
    }
}

/// Expands `(del! <path>)` to `(core/del! (path <...>))`.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_del;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("del!".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("foo".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_del(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::List(_, _)));
/// ```
pub fn expand_del(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 2 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro 'del!' expects 1 argument, but got {}",
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            let atom_symbol = WithSpan {
                value: Expr::Symbol("core/del!".to_string(), items[0].span.clone()),
                span: items[0].span.clone(),
            };
            let path_arg = &items[1];
            let canonical_path = WithSpan {
                value: Expr::Path(expr_to_path(path_arg)?, path_arg.span.clone()),
                span: path_arg.span.clone(),
            };
            Ok(WithSpan {
                value: Expr::List(vec![atom_symbol, canonical_path], span.clone()),
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro("Macro 'del!' can only be applied to a list.".to_string()),
            span: Some(expr.span.clone()),
        }),
    }
}

// ---
// Conditional Macros
// ---

/// Expands `(if <cond> <then> <else>)` to a canonical `Expr::If` node.
///
/// # Examples
///
/// ```rust
/// use sutra::ast::{Expr, Span, WithSpan};
/// use sutra::macros_std::expand_if;
/// let expr = WithSpan {
///     value: Expr::List(vec![
///         WithSpan { value: Expr::Symbol("if".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("cond".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("then".to_string(), Span::default()), span: Span::default() },
///         WithSpan { value: Expr::Symbol("else".to_string(), Span::default()), span: Span::default() },
///     ], Span::default()),
///     span: Span::default(),
/// };
/// let expanded = expand_if(&expr).unwrap();
/// assert!(matches!(expanded.value, Expr::If { .. }));
/// ```
pub fn expand_if(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, SutraError> {
    match &expr.value {
        Expr::List(items, span) => {
            if items.len() != 4 {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Macro 'if' expects 3 arguments, but got {}",
                        items.len() - 1
                    )),
                    span: Some(span.clone()),
                });
            }
            Ok(WithSpan {
                value: Expr::If {
                    condition: Box::new(items[1].clone()),
                    then_branch: Box::new(items[2].clone()),
                    else_branch: Box::new(items[3].clone()),
                    span: span.clone(),
                },
                span: span.clone(),
            })
        }
        _ => Err(SutraError {
            kind: SutraErrorKind::Macro("Macro 'if' can only be applied to a list.".to_string()),
            span: Some(expr.span.clone()),
        }),
    }
}
</file>

<file path="macros.rs">
//! # Sutra Macro Expansion System
//!
//! This module is responsible for the purely syntactic transformation of the AST
//! before evaluation. Macros allow authors to create high-level abstractions
//! that expand into simpler, core expressions.
//!
//! ## Core Principles
//!
//! - **Syntactic Only**: Macros operate solely on the AST (`WithSpan<Expr>`). They have no access
//!   to the `World` state and cannot perform any evaluation or side effects.
//! - **Pure Transformation**: Macro expansion is a pure function: `(WithSpan<Expr>) -> Result<WithSpan<Expr>, Error>`.
//! - **Inspectable**: The expansion process can be traced, allowing authors to see
//!   how their high-level forms are desugared into core language constructs.
//! - **Layered**: The macro system is a distinct pipeline stage that runs after parsing
//!   and before validation and evaluation.
//!
//! **INVARIANT:** All macroexpander logic, macro functions, and recursive expansion must operate on `WithSpan<Expr>`. Never unwrap to a bare `Expr` except for internal logic, and always re-wrap with the correct span. All lists are `Vec<WithSpan<Expr>>`.
//!
//! ## DEPRECATION NOTICE
//!
//! The legacy macroexpander API (functions operating on bare `Expr`, e.g., `expand_recursive`, `expand`, etc.) is deprecated.
//! All macroexpander logic, macro functions, and recursive expansion must operate on `WithSpan<Expr>`. Never unwrap to a bare `Expr` except for internal logic, and always re-wrap with the correct span. All lists are `Vec<WithSpan<Expr>>`.
//!
//! Use only the canonical API: `MacroExpander` and `SutraMacroExpander` trait, which operate on `WithSpan<Expr>`.
//!
//! The legacy API will be removed in a future release. See the architecture docs for details.

use crate::ast::{Expr, WithSpan};
use crate::error::{SutraError, SutraErrorKind};
use crate::macros_std;
use std::collections::HashMap;
use sha2::{Digest, Sha256};
use serde::{Serialize, Deserialize, Serializer, Deserializer};
use serde::de::VariantAccess;
use std::fs;

/// Represents a single step in the macro expansion trace.
#[derive(Debug, Clone)]
pub struct TraceStep {
    /// A description of what happened in this step, e.g., "Expanding macro 'is?'".
    pub description: String,
    /// The state of the AST after this step's transformation.
    pub ast: Expr,
}

// A macro function is a native Rust function that transforms an AST.
pub type MacroFn = fn(&crate::ast::WithSpan<crate::ast::Expr>) -> Result<crate::ast::WithSpan<crate::ast::Expr>, crate::error::SutraError>;

/// A declarative macro defined by a template.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MacroTemplate {
    pub params: crate::ast::ParamList,
    pub body: Box<WithSpan<Expr>>,
}

/// MacroDef cannot serialize/deserialize native function pointers. Only Template variant is serializable.
#[derive(Debug, Clone)]
pub enum MacroDef {
    Fn(MacroFn),
    Template(MacroTemplate),
}

// Custom Serialize/Deserialize for MacroDef
impl Serialize for MacroDef {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            MacroDef::Template(tmpl) => {
                serializer.serialize_newtype_variant("MacroDef", 1, "Template", tmpl)
            }
            MacroDef::Fn(_) => {
                // Native functions are not serializable; skip or error.
                serializer.serialize_unit_variant("MacroDef", 0, "Fn")
            }
        }
    }
}

impl<'de> Deserialize<'de> for MacroDef {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(field_identifier, rename_all = "lowercase")]
        enum Field { Fn, Template }

        struct MacroDefVisitor;
        impl<'de> serde::de::Visitor<'de> for MacroDefVisitor {
            type Value = MacroDef;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("enum MacroDef")
            }
            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::EnumAccess<'de>,
            {
                let (field, variant) = data.variant::<String>()?;
                match field.as_str() {
                    "Template" => {
                        let tmpl = variant.newtype_variant::<MacroTemplate>()?;
                        Ok(MacroDef::Template(tmpl))
                    }
                    "Fn" => {
                        // Cannot deserialize native function pointers; return error or skip.
                        Err(serde::de::Error::custom("Cannot deserialize MacroDef::Fn variant"))
                    }
                    _ => Err(serde::de::Error::unknown_variant(&field, &[])),
                }
            }
        }
        deserializer.deserialize_enum("MacroDef", &["Fn", "Template"], MacroDefVisitor)
    }
}

/// Macro registry for built-in and template macros.
///
/// # Example
/// ```rust
/// use crate::macros::{MacroRegistry, MacroDef};
/// let mut registry = MacroRegistry::default();
/// // Add a built-in macro
/// registry.macros.insert("inc".to_string(), MacroDef::Fn(|_| unimplemented!()));
/// ```
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct MacroRegistry {
    /// Map from macro name to macro definition (built-in or template).
    pub macros: std::collections::HashMap<String, MacroDef>,
}

/// Macro context for macroexpansion, including registry and hygiene scope.
///
/// # Example
/// ```rust
/// use crate::macros::{MacroRegistry, SutraMacroContext};
/// let context = SutraMacroContext { registry: MacroRegistry::default(), hygiene_scope: None };
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SutraMacroContext {
    /// Macro registry (built-in and template macros).
    pub registry: MacroRegistry,
    /// Hygiene scope for macro expansion (optional, for future extensibility).
    pub hygiene_scope: Option<String>,
    // Extend as needed for user macros, environment, etc.
}

impl SutraMacroContext {
    /// Looks up a macro by name in the registry.
    ///
    /// # Example
    /// ```rust
    /// use crate::macros::{MacroRegistry, SutraMacroContext, MacroDef};
    /// let mut registry = MacroRegistry::default();
    /// registry.macros.insert("foo".to_string(), MacroDef::Fn(|_| unimplemented!()));
    /// let context = SutraMacroContext { registry, hygiene_scope: None };
    /// assert!(context.get_macro("foo").is_some());
    /// ```
    pub fn get_macro(&self, name: &str) -> Option<&MacroDef> {
        self.registry.macros.get(name)
    }
}

impl MacroRegistry {
    /// Creates a new, empty macro registry.
    pub fn new() -> Self {
        Self::default()
    }

    /// Registers a new macro with the given name.
    pub fn register(&mut self, name: &str, func: MacroFn) {
        self.macros.insert(name.to_string(), MacroDef::Fn(func));
    }

    fn expand_template(
        &self,
        template: &MacroTemplate,
        expr: &WithSpan<Expr>,
        depth: usize,
    ) -> Result<WithSpan<Expr>, SutraError> {
        let (items, span) = match &expr.value {
            Expr::List(items, span) => (items, span),
            _ => {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(
                        "Template macro must be called as a list.".to_string(),
                    ),
                    span: Some(expr.span.clone()),
                });
            }
        };

        let args = &items[1..];

        // Arity check: too few arguments
        if args.len() < template.params.required.len() {
            return Err(SutraError {
                kind: SutraErrorKind::Macro(format!(
                    "Macro expects at least {} arguments, but got {}.",
                    template.params.required.len(),
                    args.len()
                )),
                span: Some(span.clone()),
            });
        }

        // Too many arguments for non-variadic macro
        if template.params.rest.is_none() && args.len() > template.params.required.len() {
            return Err(SutraError {
                kind: SutraErrorKind::Macro(format!(
                    "Macro expects exactly {} arguments, but got {}.",
                    template.params.required.len(),
                    args.len()
                )),
                span: Some(span.clone()),
            });
        }

        // Bind fixed parameters positionally
        let mut bindings = HashMap::new();
        for (i, param_name) in template.params.required.iter().enumerate() {
            bindings.insert(param_name.clone(), args[i].clone());
        }

        // Bind variadic parameter (if present) to a list of remaining args (may be empty)
        if let Some(variadic_name) = &template.params.rest {
            let rest_args = if args.len() > template.params.required.len() {
                args[template.params.required.len()..].to_vec()
            } else {
                vec![]
            };
            bindings.insert(
                variadic_name.clone(),
                WithSpan {
                    value: Expr::List(rest_args, span.clone()),
                    span: span.clone(),
                },
            );
        }

        // TODO: Consider moving arity/positional validation to MacroTemplate::new if possible.

        let substituted_body = self.substitute(&template.body, &bindings)?;
        Ok(substituted_body)
    }

    fn substitute(
        &self,
        expr: &WithSpan<Expr>,
        bindings: &HashMap<String, WithSpan<Expr>>,
    ) -> Result<WithSpan<Expr>, SutraError> {
        match &expr.value {
            Expr::Symbol(name, span) => {
                if let Some(bound_expr) = bindings.get(name) {
                    Ok(bound_expr.clone())
                } else {
                    Ok(WithSpan { value: Expr::Symbol(name.clone(), span.clone()), span: expr.span.clone() })
                }
            }
            Expr::Quote(inner, span) => {
                let new_inner = self.substitute(inner, bindings)?;
                Ok(WithSpan { value: Expr::Quote(Box::new(new_inner), span.clone()), span: expr.span.clone() })
            }
            Expr::List(items, span) => {
                let new_items = items
                    .iter()
                    .map(|item| self.substitute(item, bindings))
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(WithSpan { value: Expr::List(new_items, span.clone()), span: expr.span.clone() })
            }
            Expr::If {
                condition,
                then_branch,
                else_branch,
                span,
            } => {
                let new_condition = self.substitute(condition, bindings)?;
                let new_then = self.substitute(then_branch, bindings)?;
                let new_else = self.substitute(else_branch, bindings)?;
                Ok(WithSpan {
                    value: Expr::If {
                        condition: Box::new(new_condition),
                        then_branch: Box::new(new_then),
                        else_branch: Box::new(new_else),
                        span: span.clone(),
                    },
                    span: expr.span.clone(),
                })
            }
            // Literals and paths are returned as-is
            _ => Ok(expr.clone()),
        }
    }

    /// The recursive implementation for `macroexpand_trace`.
    fn trace_recursive(
        &self,
        expr: &WithSpan<Expr>,
        trace: &mut Vec<TraceStep>,
        depth: usize,
    ) -> Result<WithSpan<Expr>, SutraError> {
        const MAX_DEPTH: usize = 100;
        if depth > MAX_DEPTH {
            return Err(SutraError {
                kind: SutraErrorKind::Macro("Macro expansion depth limit exceeded.".to_string()),
                span: Some(expr.span.clone()),
            });
        }

        if let Expr::If {
            condition,
            then_branch,
            else_branch,
            span,
        } = &expr.value
        {
            let expanded_condition = self.trace_recursive(condition, trace, depth + 1)?;
            let expanded_then = self.trace_recursive(then_branch, trace, depth + 1)?;
            let expanded_else = self.trace_recursive(else_branch, trace, depth + 1)?;
            return Ok(WithSpan {
                value: Expr::If {
                    condition: Box::new(expanded_condition),
                    then_branch: Box::new(expanded_then),
                    else_branch: Box::new(expanded_else),
                    span: span.clone(),
                },
                span: expr.span.clone(),
            });
        }

        let (items, span) = match &expr.value {
            Expr::List(items, span) => (items, span),
            Expr::Quote(inner, span) => {
                // Do not expand inside quotes; return as-is
                return Ok(WithSpan {
                    value: Expr::Quote(inner.clone(), span.clone()),
                    span: expr.span.clone(),
                });
            }
            _ => return Ok(expr.clone()),
        };

        if items.is_empty() {
            return Ok(expr.clone());
        }

        if let Some(WithSpan { value: Expr::Symbol(s, _), .. }) = items.get(0) {
            if let Some(macro_def) = self.macros.get(s) {
                let expanded = match macro_def {
                    MacroDef::Fn(func) => func(expr)?,
                    MacroDef::Template(template) => self.expand_template(template, expr, depth)?,
                };
                trace.push(TraceStep {
                    description: format!("Expanding macro `{}`", s),
                    ast: expanded.value.clone(),
                });
                return self.trace_recursive(&expanded, trace, depth + 1);
            }
        }

        let expanded_items = items
            .iter()
            .map(|item| self.trace_recursive(item, trace, depth + 1))
            .collect::<Result<Vec<WithSpan<Expr>>, _>>()?;

        Ok(WithSpan {
            value: Expr::List(expanded_items, span.clone()),
            span: expr.span.clone(),
        })
    }

    /// Computes a SHA256 hash of all macro names and their source/expansion forms, sorted deterministically.
    pub fn hash(&self) -> String {
        let mut entries: Vec<(String, String)> = self.macros.iter().map(|(name, def)| {
            let def_str = match def {
                MacroDef::Template(template) => {
                    // Serialize params, variadic_param, and body in a stable way
                    let mut s = String::new();
                    s.push_str(&format!("params:{:?};", template.params));
                    s.push_str(&format!("variadic:{:?};", template.params.rest));
                    s.push_str(&format!("body:{};", template.body.value.pretty()));
                    s
                }
                MacroDef::Fn(_) => "native_fn".to_string(),
            };
            (name.clone(), def_str)
        }).collect();
        entries.sort_by(|a, b| a.0.cmp(&b.0));
        let mut hasher = Sha256::new();
        for (name, def_str) in entries {
            hasher.update(name.as_bytes());
            hasher.update(def_str.as_bytes());
        }
        let result = hasher.finalize();
        format!("{:x}", result)
    }
}

impl MacroTemplate {
    /// Constructs a MacroTemplate with validation for duplicate parameters.
    pub fn new(
        params: crate::ast::ParamList,
        body: Box<WithSpan<Expr>>,
    ) -> Result<Self, SutraError> {
        // Check for duplicate parameter names
        let mut all_names = params.required.clone();
        if let Some(var) = &params.rest {
            all_names.push(var.clone());
        }
        let mut seen = std::collections::HashSet::new();
        for name in &all_names {
            if !seen.insert(name) {
                return Err(SutraError {
                    kind: SutraErrorKind::Macro(format!(
                        "Duplicate parameter name '{}' in macro definition.",
                        name
                    )),
                    span: Some(params.span.clone()),
                });
            }
        }
        Ok(MacroTemplate {
            params,
            body,
        })
    }
}

/// Pure loader: parses macro definitions from a Sutra source string.
pub fn parse_macros_from_source(source: &str) -> Result<Vec<(String, MacroTemplate)>, SutraError> {
    use crate::parser;
    use crate::ast::Expr;
    use std::collections::{HashMap, HashSet};

    let exprs = parser::parse(source)?;
    let mut macros = Vec::new();
    let mut names_seen = HashSet::new();

    for expr in exprs {
        // Only process (define (name ...) body) forms
        if let Expr::List(items, span) = &expr.value {
            if items.len() == 3 {
                if let Expr::Symbol(def, _) = &items[0].value {
                    if def == "define" {
                        // Parse parameter list
                        match &items[1].value {
                            Expr::ParamList(param_list) => {
                                let macro_name = if let Some(name) = param_list.required.first() {
                                    name.clone()
                                } else {
                                    return Err(SutraError {
                                        kind: SutraErrorKind::Macro("Macro name must be the first element of the parameter list.".to_string()),
                                        span: Some(param_list.span.clone()),
                                    });
                                };
                                if !names_seen.insert(macro_name.clone()) {
                                    return Err(SutraError {
                                        kind: SutraErrorKind::Macro(format!("Duplicate macro name '{}'.", macro_name)),
                                        span: Some(param_list.span.clone()),
                                    });
                                }
                                // The rest of required are the macro parameters
                                let params = crate::ast::ParamList {
                                    required: param_list.required[1..].to_vec(),
                                    rest: param_list.rest.clone(),
                                    span: param_list.span.clone(),
                                };
                                let template = MacroTemplate::new(
                                    params,
                                    Box::new(items[2].clone()),
                                )?;
                                macros.push((macro_name, template));
                            }
                            _ => {
                                return Err(SutraError {
                                    kind: SutraErrorKind::Macro("Macro parameter list must be a ParamList.".to_string()),
                                    span: Some(items[1].span.clone()),
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    Ok(macros)
}

/// Thin wrapper: loads macro definitions from a file.
pub fn load_macros_from_file(path: &str) -> Result<Vec<(String, MacroTemplate)>, SutraError> {
    let source = fs::read_to_string(path)
        .map_err(|e| SutraError { kind: SutraErrorKind::Io(e.to_string()), span: None })?;
    parse_macros_from_source(&source)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SutraMacroError {
    Expansion { span: crate::ast::Span, macro_name: String, message: String },
    RecursionLimit { span: crate::ast::Span, macro_name: String },
    // ...
}

/// Canonical macroexpander trait for the modular pipeline.
pub trait SutraMacroExpander {
    fn expand_macros(&self, ast: crate::ast::WithSpan<crate::ast::Expr>, context: &SutraMacroContext) -> Result<crate::ast::WithSpan<crate::ast::Expr>, SutraMacroError>;
}

/// Macroexpander for the modular pipeline (Sprint 4).
pub struct MacroExpander {
    pub max_recursion: usize,
}

impl Default for MacroExpander {
    fn default() -> Self {
        Self { max_recursion: 32 }
    }
}

impl SutraMacroExpander for MacroExpander {
    fn expand_macros(&self, ast: crate::ast::WithSpan<crate::ast::Expr>, context: &SutraMacroContext) -> Result<crate::ast::WithSpan<crate::ast::Expr>, SutraMacroError> {
        expand_macros_rec(&ast, context, 0, self.max_recursion)
    }
}

fn expand_macros_rec(
    ast: &WithSpan<Expr>,
    context: &SutraMacroContext,
    depth: usize,
    max_depth: usize,
) -> Result<WithSpan<Expr>, SutraMacroError> {
    if depth > max_depth {
        return Err(SutraMacroError::RecursionLimit {
            span: ast.span.clone(),
            macro_name: "<unknown>".to_string(),
        });
    }
    match &ast.value {
        Expr::List(items, span) => {
            if items.is_empty() {
                return Ok(ast.clone());
            }
            if let Some(WithSpan { value: Expr::Symbol(s, _), .. }) = items.get(0) {
                if let Some(macro_def) = context.registry.macros.get(s) {
                    let expanded = match macro_def {
                        MacroDef::Fn(func) => func(ast).map_err(|e| SutraMacroError::Expansion {
                            span: ast.span.clone(),
                            macro_name: s.clone(),
                            message: e.to_string(),
                        })?,
                        MacroDef::Template(template) => context.registry.expand_template(template, ast, depth).map_err(|e| SutraMacroError::Expansion {
                            span: ast.span.clone(),
                            macro_name: s.clone(),
                            message: e.to_string(),
                        })?,
                    };
                    return expand_macros_rec(&expanded, context, depth + 1, max_depth);
                }
            }
            let expanded_items = items
                .iter()
                .map(|item| expand_macros_rec(item, context, depth + 1, max_depth))
                .collect::<Result<Vec<WithSpan<Expr>>, _>>()?;
            Ok(WithSpan {
                value: Expr::List(expanded_items, span.clone()),
                span: ast.span.clone(),
            })
        }
        Expr::If { condition, then_branch, else_branch, span } => {
            let cond = expand_macros_rec(condition, context, depth, max_depth)?;
            let then_b = expand_macros_rec(then_branch, context, depth, max_depth)?;
            let else_b = expand_macros_rec(else_branch, context, depth, max_depth)?;
            Ok(WithSpan {
                value: Expr::If {
                    condition: Box::new(cond),
                    then_branch: Box::new(then_b),
                    else_branch: Box::new(else_b),
                    span: span.clone(),
                },
                span: ast.span.clone(),
            })
        }
        _ => Ok(ast.clone()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::{Expr, WithSpan, Span};
    use std::collections::HashMap;

    fn make_symbol(name: &str, span: Span) -> WithSpan<Expr> {
        WithSpan { value: Expr::Symbol(name.to_string(), span.clone()), span }
    }
    fn make_list(items: Vec<WithSpan<Expr>>, span: Span) -> WithSpan<Expr> {
        WithSpan { value: Expr::List(items, span.clone()), span }
    }

    #[test]
    fn expands_builtin_macro() {
        fn inc_macro(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, crate::error::SutraError> {
            if let Expr::List(items, span) = &expr.value {
                if items.len() == 2 {
                    Ok(WithSpan {
                        value: Expr::List(
                            vec![
                                WithSpan { value: Expr::Symbol("+".to_string(), span.clone()), span: span.clone() },
                                items[1].clone(),
                                WithSpan { value: Expr::Number(1.0, span.clone()), span: span.clone() },
                            ],
                            span.clone(),
                        ),
                        span: span.clone(),
                    })
                } else {
                    Err(crate::error::SutraError {
                        kind: crate::error::SutraErrorKind::Macro("inc expects 1 arg".to_string()),
                        span: Some(span.clone()),
                    })
                }
            } else {
                Err(crate::error::SutraError {
                    kind: crate::error::SutraErrorKind::Macro("inc expects list".to_string()),
                    span: None,
                })
            }
        }
        let mut registry = MacroRegistry::default();
        registry.macros.insert("inc".to_string(), MacroDef::Fn(inc_macro));
        let context = SutraMacroContext { registry, hygiene_scope: None };
        let span = Span { start: 0, end: 7 };
        let ast = make_list(
            vec![make_symbol("inc", span.clone()), make_symbol("x", span.clone())],
            span.clone(),
        );
        let expander = MacroExpander::default();
        let expanded = expander.expand_macros(ast, &context).unwrap();
        if let Expr::List(items, _) = &expanded.value {
            assert_eq!(items.len(), 3);
            assert!(matches!(&items[0].value, Expr::Symbol(s, _) if s == "+"));
            assert!(matches!(&items[1].value, Expr::Symbol(s, _) if s == "x"));
            assert!(matches!(&items[2].value, Expr::Number(n, _) if *n == 1.0));
        } else {
            panic!("Expected expanded macro to be a list");
        }
    }

    #[test]
    fn recursion_limit() {
        fn self_macro(expr: &WithSpan<Expr>) -> Result<WithSpan<Expr>, crate::error::SutraError> {
            Ok(expr.clone())
        }
        let mut registry = MacroRegistry::default();
        registry.macros.insert("self".to_string(), MacroDef::Fn(self_macro));
        let context = SutraMacroContext { registry, hygiene_scope: None };
        let span = Span { start: 0, end: 6 };
        let ast = make_list(vec![make_symbol("self", span.clone())], span.clone());
        let expander = MacroExpander { max_recursion: 4 };
        let err = expander.expand_macros(ast, &context).unwrap_err();
        match err {
            SutraMacroError::RecursionLimit { .. } => {}
            _ => panic!("Expected recursion limit error"),
        }
    }

    #[test]
    fn undefined_macro_returns_input() {
        let registry = MacroRegistry::default();
        let context = SutraMacroContext { registry, hygiene_scope: None };
        let span = Span { start: 0, end: 5 };
        let ast = make_list(vec![make_symbol("foo", span.clone())], span.clone());
        let expander = MacroExpander::default();
        let expanded = expander.expand_macros(ast, &context).unwrap();
        assert!(matches!(&expanded.value, Expr::List(_, _)));
    }
}
</file>

<file path="main.rs">
fn main() {
    sutra::cli::run();
}
</file>

<file path="parser.rs">
// Sutra Engine - Unified PEG-based Parser
// =======================================
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/sutra.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.
//!
//! # Sutra Parser: Grammar-to-AST Mapping
//!
//! | PEG Rule      | AST Node         | Notes                         |
//! |---------------|------------------|-------------------------------|
//! | program       | Vec<Expr>        | Top-level expressions; see note below |
//! | expr          | Expr             | Delegates to subrules         |
//! | list          | Expr::List       | Regular list only             |
//! | dotted_list   | (REMOVED)        | (REMOVED)                     |
//! | block         | Expr::List       | Brace blocks                  |
//! | atom          | Expr             | Number, Bool, String, Symbol  |
//! | number        | Expr::Number     |                               |
//! | boolean       | Expr::Bool       |                               |
//! | string        | Expr::String     |                               |
//! | symbol        | Expr::Symbol     |                               |
//!
//! **Span conventions:**
//! - All AST nodes carry a span covering the full source range of the parsed form.
//! - For dotted lists, the dot is represented as `Expr::Symbol(".")` with the span of the entire dotted list (not just the dot token).
//! - This is intentional for simplicity and is documented for downstream consumers.
//!
//! **Program node representation:**
//! - The public `parse` API returns a `Vec<Expr>` for top-level forms.
//! - Internally, `build_program` returns an `Expr::List` for uniformity, but this is unwrapped by `parse`.
//! - If a canonical program node is ever needed, document and update accordingly.

use crate::ast::{Expr, Span, WithSpan};
use crate::error::{SutraError, SutraErrorKind};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;
use once_cell::sync::Lazy;
use std::collections::HashMap;

// This derive macro generates the parser implementation from our grammar file.
#[derive(Parser)]
#[grammar = "sutra.pest"]
struct SutraParser;

/// Parses a source string into a vector of top-level Sutra `Expr` AST nodes.
///
/// This function is the sole public entry point to the parser. It is purely
/// syntactic and does not add any semantic wrappers like `(do ...)`.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Vec<Expr>)` - A vector of expressions found at the top level of the source.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source: &str) -> Result<Vec<WithSpan<Expr>>, SutraError> {
    // `SutraParser::parse` attempts to match the `program` rule from the grammar.
    // If it fails, it returns a `pest` error, which we map to our `SutraError`.
    let pairs = SutraParser::parse(Rule::program, source).map_err(|e| {
        // TODO: A future improvement would be to use a library like `pest_consume`
        // or write a more detailed error formatter to give even more user-friendly
        // error messages than the default `pest` provides.
        let span = match e.location {
            pest::error::InputLocation::Pos(pos) => Span {
                start: pos,
                end: pos,
            },
            pest::error::InputLocation::Span((start, end)) => Span { start, end },
        };
        SutraError {
            kind: SutraErrorKind::Parse(e.to_string()),
            span: Some(span),
        }
    })?;

    // The `program` rule is guaranteed to have one inner pair (itself) if parsing succeeds.
    let root_pair = pairs.peek().ok_or_else(|| SutraError {
        kind: SutraErrorKind::Parse(
            "Parser generated an empty tree, this should not happen.".to_string(),
        ),
        span: None,
    })?;

    // We build the AST from all expressions found inside the `program` rule.
    root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect()
}

// Utility function for consistent span extraction
fn get_span(pair: &pest::iterators::Pair<Rule>) -> Span {
    Span { start: pair.as_span().start(), end: pair.as_span().end() }
}

// Type alias for AST builder functions
pub type AstBuilderFn = fn(Pair<Rule>) -> Result<WithSpan<Expr>, SutraError>;

// Static map from Rule to handler function
pub static AST_BUILDERS: Lazy<HashMap<Rule, AstBuilderFn>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert(Rule::program, build_program as AstBuilderFn);
    m.insert(Rule::expr, build_expr as AstBuilderFn);
    m.insert(Rule::list, build_list as AstBuilderFn);
    m.insert(Rule::param_list, build_param_list as AstBuilderFn);
    m.insert(Rule::block, build_block as AstBuilderFn);
    m.insert(Rule::number, build_number as AstBuilderFn);
    m.insert(Rule::boolean, build_boolean as AstBuilderFn);
    m.insert(Rule::string, build_string as AstBuilderFn);
    m.insert(Rule::symbol, build_symbol as AstBuilderFn);
    m.insert(Rule::quote, build_quote as AstBuilderFn);
    m.insert(Rule::define_form, build_define_form as AstBuilderFn);
    m.insert(Rule::atom, build_atom as AstBuilderFn);
    m
});

// Dispatcher: looks up the handler in the map and calls it
fn build_ast_from_pair(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    AST_BUILDERS.get(&pair.as_rule())
        .ok_or_else(|| SutraError {
            kind: SutraErrorKind::InternalParse(format!(
                "No AST builder registered for rule: {:?} (input: '{}')",
                pair.as_rule(), pair.as_str()
            )),
            span: Some(get_span(&pair)),
        })?
        (pair)
}

/// Handles the top-level program rule.
///
/// Note: Returns an `Expr::List` for internal uniformity, but the public `parse` API collects top-level forms as a `Vec<Expr>`.
/// If a canonical program node is ever needed, update this convention and document accordingly.
fn build_program(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let exprs = pair
        .clone()
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect::<Result<Vec<_>, _>>()?;
    Ok(WithSpan {
        value: Expr::List(exprs, span.clone()),
        span,
    })
}

/// Handles expr rule (delegates to subrules).
fn build_expr(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst(format!(
            "Empty expr pair (input: '{}')",
            pair.as_str()
        )),
        span: Some(span),
    })?;
    build_ast_from_pair(sub)
}

/// Handles list rule (proper lists only).
fn build_list(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let items = pair.clone().into_inner().map(build_ast_from_pair).collect::<Result<Vec<_>, _>>()?;
    Ok(WithSpan {
        value: Expr::List(items, span.clone()),
        span,
    })
}

fn build_param_list(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner().peekable();
    let mut required = Vec::new();
    let mut rest: Option<String> = None;
    while let Some(p) = inner.next() {
        if p.as_rule() == Rule::symbol {
            let sym = match build_symbol(p)? {
                WithSpan { value: Expr::Symbol(s, _), .. } => s,
                _ => unreachable!("build_symbol must return Expr::Symbol for Rule::symbol"),
            };
            if rest.is_some() {
                // No required params after ...rest
                return Err(SutraError {
                    kind: SutraErrorKind::Parse("Required parameter after ...rest in parameter list".to_string()),
                    span: Some(span.clone()),
                });
            }
            required.push(sym);
        } else if p.as_str() == "..." {
            // Next must be a symbol
            let next = inner.next().ok_or_else(|| SutraError {
                kind: SutraErrorKind::Parse("Expected symbol after ... in parameter list".to_string()),
                span: Some(span.clone()),
            })?;
            if next.as_rule() != Rule::symbol {
                return Err(SutraError {
                    kind: SutraErrorKind::Parse("Expected symbol after ... in parameter list".to_string()),
                    span: Some(span.clone()),
                });
            }
            let sym = match build_symbol(next)? {
                WithSpan { value: Expr::Symbol(s, _), .. } => s,
                _ => unreachable!("build_symbol must return Expr::Symbol for Rule::symbol"),
            };
            if rest.is_some() {
                return Err(SutraError {
                    kind: SutraErrorKind::Parse("Multiple ...rest in parameter list".to_string()),
                    span: Some(span.clone()),
                });
            }
            rest = Some(sym);
        } else {
            return Err(SutraError {
                kind: SutraErrorKind::Parse(format!("Invalid parameter: expected symbol or ...rest, found '{}'.", p.as_str())),
                span: Some(span.clone()),
            });
        }
    }
    Ok(WithSpan {
        value: Expr::ParamList(crate::ast::ParamList {
            required,
            rest,
            span: span.clone(),
        }),
        span,
    })
}

/// Handles block rule (brace blocks).
fn build_block(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let items = pair.clone().into_inner().map(build_ast_from_pair).collect::<Result<Vec<_>, _>>()?;
    Ok(WithSpan {
        value: Expr::List(items, span.clone()),
        span,
    })
}

/// Handles atom rule (delegates to subrules).
fn build_atom(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst(format!(
            "Empty atom pair (input: '{}')",
            pair.as_str()
        )),
        span: Some(span),
    })?;
    build_ast_from_pair(sub)
}

/// Handles number rule.
fn build_number(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let s = pair.as_str();
    let n = s.parse().map_err(|e| SutraError {
        kind: SutraErrorKind::Parse(format!("number: Invalid number: expected numeric literal, found '{}', error: {}", s, e)),
        span: Some(span.clone()),
    })?;
    Ok(WithSpan {
        value: Expr::Number(n, span.clone()),
        span,
    })
}

/// Handles boolean rule.
fn build_boolean(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let s = pair.as_str();
    match s {
        "true" => Ok(WithSpan { value: Expr::Bool(true, span.clone()), span }),
        "false" => Ok(WithSpan { value: Expr::Bool(false, span.clone()), span }),
        _ => Err(SutraError {
            kind: SutraErrorKind::Parse(format!("boolean: Invalid boolean: expected 'true' or 'false', found '{}'", s)),
            span: Some(span),
        }),
    }
}

/// Handles string rule.
fn build_string(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    Ok(WithSpan {
        value: Expr::String(unescape_string(pair.clone())?, span.clone()),
        span,
    })
}

/// Handles symbol rule.
fn build_symbol(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    Ok(WithSpan {
        value: Expr::Symbol(pair.as_str().to_string(), span.clone()),
        span,
    })
}

/// Pure helper function to unescape a string from a `pest` `Pair`.
///
/// Note: Only supports basic escapes (\n, \t, \\, \"). Unicode (\uXXXX) and hex/octal escapes are NOT supported.
/// This is sufficient for current narrative scripting, but should be extended if such escapes are needed in the future.
fn unescape_string(pair: Pair<Rule>) -> Result<String, SutraError> {
    // The `string` rule in the grammar is `@{ "\"" ~ inner ~ "\"" }`.
    // `pair.as_str()` gives us the full text, including the surrounding quotes.
    let full_str = pair.as_str();

    // We slice the string to remove the first and last characters (the quotes).
    // This is simpler and more robust than traversing the CST, even if it's
    // slightly less performant for very long strings. The correctness and
    // simplicity trade-off is worth it here.
    let inner_str = &full_str[1..full_str.len() - 1];

    // Now, we manually unescape the recognized sequences.
    let mut result = String::with_capacity(inner_str.len());
    let mut chars = inner_str.chars();
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('t') => result.push('\t'),
                Some('\\') => result.push('\\'),
                Some('"') => result.push('"'),
                // If we encounter an invalid escape, we just push the characters
                // literally. The grammar should prevent this, but this is safer.
                Some(other) => {
                    result.push('\\');
                    result.push(other);
                }
                // A dangling escape at the end of a string.
                None => result.push('\\'),
            }
        } else {
            result.push(c);
        }
    }
    Ok(result)
}

/// Canonical CST node for the parsing pipeline (modular, interface-driven).
#[derive(Debug, Clone, PartialEq)]
pub struct SutraCstNode {
    pub rule: String, // Use String for rule name for now; can be enum if desired
    pub children: Vec<SutraCstNode>,
    pub span: crate::ast::Span,
    // Optionally: text, parent, etc.
}

#[derive(Debug, Clone, PartialEq)]
pub enum SutraCstParseError {
    Syntax { span: crate::ast::Span, message: String },
    Incomplete { span: crate::ast::Span, message: String },
    // ...
}

/// Canonical trait for a CST parser (modular pipeline contract).
pub trait SutraCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError>;
    fn traverse<'a>(&'a self, node: &'a SutraCstNode) -> SutraCstTraversal<'a>;
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(&'a self, node: &'a SutraCstNode, visitor: F, order: TraversalOrder);
}

/// Iterator for CST traversal (DFS/BFS).
pub struct SutraCstTraversal<'a> {
    // Implementation details omitted for now
    _phantom: std::marker::PhantomData<&'a SutraCstNode>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TraversalOrder { DepthFirst, BreadthFirst }

/// Trivial CST parser for pipeline scaffolding (Sprint 2).
pub struct TrivialCstParser;

impl SutraCstParser for TrivialCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError> {
        Ok(SutraCstNode {
            rule: "Program".to_string(),
            children: vec![],
            span: crate::ast::Span { start: 0, end: input.len() },
        })
    }
    fn traverse<'a>(&'a self, node: &'a SutraCstNode) -> SutraCstTraversal<'a> {
        SutraCstTraversal { _phantom: std::marker::PhantomData }
    }
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(&'a self, _node: &'a SutraCstNode, _visitor: F, _order: TraversalOrder) {
        // No-op for trivial impl
    }
}

/// Real CST parser using pest and the canonical grammar.
pub struct PestCstParser;

impl SutraCstParser for PestCstParser {
    fn parse(&self, input: &str) -> Result<SutraCstNode, SutraCstParseError> {
        let pairs = SutraParser::parse(Rule::program, input)
            .map_err(|e| {
                let span = match e.location {
                    pest::error::InputLocation::Pos(pos) => crate::ast::Span { start: pos, end: pos },
                    pest::error::InputLocation::Span((start, end)) => crate::ast::Span { start, end },
                };
                SutraCstParseError::Syntax { span, message: e.to_string() }
            })?;
        let root_pair = pairs.peek().ok_or_else(|| SutraCstParseError::Incomplete {
            span: crate::ast::Span { start: 0, end: input.len() },
            message: "Parser generated an empty tree, this should not happen.".to_string(),
        })?;
        Ok(build_cst_from_pair(root_pair))
    }
    fn traverse<'a>(&'a self, _node: &'a SutraCstNode) -> SutraCstTraversal<'a> {
        SutraCstTraversal { _phantom: std::marker::PhantomData }
    }
    fn visit<'a, F: FnMut(&'a SutraCstNode)>(&'a self, _node: &'a SutraCstNode, _visitor: F, _order: TraversalOrder) {
        // Not implemented for now
    }
}

fn build_cst_from_pair(pair: Pair<Rule>) -> SutraCstNode {
    let span = crate::ast::Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    };
    let rule = format!("{:?}", pair.as_rule());
    let children: Vec<SutraCstNode> = pair.clone().into_inner().map(build_cst_from_pair).collect();
    SutraCstNode { rule, children, span }
}

#[cfg(test)]
mod pest_cst_tests {
    use super::*;
    #[test]
    fn pest_cst_parser_parses_simple_program() {
        let parser = PestCstParser;
        let input = "(foo 42)";
        let cst = parser.parse(input).unwrap();
        assert_eq!(cst.rule, "program");
        assert_eq!(cst.children.len(), 2); // expr + EOI
        let expr = &cst.children[0];
        assert_eq!(expr.rule, "expr");
        assert_eq!(expr.children.len(), 1);
        let list = &expr.children[0];
        assert_eq!(list.rule, "list");
        assert_eq!(list.span.start, 0);
        assert_eq!(list.span.end, 8);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn trivial_cst_parser_returns_minimal_node() {
        let parser = TrivialCstParser;
        let cst = parser.parse("(foo bar)").unwrap();
        assert_eq!(cst.rule, "Program");
        assert_eq!(cst.children.len(), 0);
        assert_eq!(cst.span.start, 0);
        assert_eq!(cst.span.end, 9);
    }
}

// Add missing handler for quote
fn build_quote(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.into_inner();
    let quoted = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst("quote: Empty quote pair (expected expr)".to_string()),
        span: Some(span.clone()),
    })?;
    let quoted_expr = build_ast_from_pair(quoted)?;
    Ok(WithSpan {
        value: Expr::Quote(Box::new(quoted_expr), span.clone()),
        span,
    })
}

// Add missing handler for define_form
fn build_define_form(pair: Pair<Rule>) -> Result<WithSpan<Expr>, SutraError> {
    let span = get_span(&pair);
    let mut inner = pair.clone().into_inner();
    // Expect: define, param_list, expr
    let _define_kw = inner.next(); // "define" symbol (skip)
    let param_list_pair = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst("define_form: Missing param_list in define_form (expected param_list)".to_string()),
        span: Some(span.clone()),
    })?;
    let param_list_expr = build_ast_from_pair(param_list_pair)?;
    let body_pair = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst("define_form: Missing body expr in define_form (expected expr)".to_string()),
        span: Some(span.clone()),
    })?;
    let body_expr = build_ast_from_pair(body_pair)?;
    Ok(WithSpan {
        value: Expr::List(
            vec![
                WithSpan { value: Expr::Symbol("define".to_string(), span.clone()), span: span.clone() },
                param_list_expr,
                body_expr,
            ],
            span.clone(),
        ),
        span,
    })
}
</file>

<file path="path.rs">
//! A canonical, type-safe representation of a path into the world state.

use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Path(pub Vec<String>);
</file>

<file path="registry.rs">
//! # Sutra Engine: Canonical Registry Builder
//!
//! Provides a single, canonical function to construct a fully populated atom and macro registry
//! for both production and test use. This eliminates duplication and ensures all code paths
//! share the same registration logic.

use crate::atom::AtomRegistry;
use crate::atoms_std;
use crate::macros::MacroRegistry;
use crate::macros_std;

/// Builds and returns a fully populated atom registry with all standard atoms registered.
///
/// # Example
/// ```
/// use sutra::registry::build_default_atom_registry;
/// let registry = build_default_atom_registry();
/// ```
#[inline]
pub fn build_default_atom_registry() -> AtomRegistry {
    let mut registry = AtomRegistry::new();
    atoms_std::register_std_atoms(&mut registry);
    registry
}

/// Builds and returns a fully populated macro registry with all standard macros registered.
///
/// # Example
/// ```
/// use sutra::registry::build_default_macro_registry;
/// let registry = build_default_macro_registry();
/// ```
#[inline]
pub fn build_default_macro_registry() -> MacroRegistry {
    let mut registry = MacroRegistry::new();
    macros_std::register_std_macros(&mut registry);
    registry
}
</file>

<file path="sutra.pest">
// Sutra Engine PEG Grammar (v4.1 - Audited & Commented)
// ====================================================
// This grammar has been refined after a thorough audit to improve the robustness
// of the parser's error reporting, especially for string escape sequences.
// Every rule is commented to clarify its intent and purpose.

// -- Special Rules --

// `WHITESPACE` and `COMMENT` are silent rules (`_`) that `pest` can apply
// implicitly between any other rules. This keeps the main grammar clean.
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ ";" ~ (!"\n" ~ ANY)* }

// -- Core Grammar Rules --

// A `program` is the top-level rule, consisting of zero or more expressions.
// `SOI` (Start of Input) and `EOI` (End of Input) anchor the parse to ensure
// the entire input string is consumed.
program = { SOI ~ expr* ~ EOI }

// An `expr` (expression) is the fundamental recursive unit of the language.
expr = { define_form | quote | list | block | atom }

// `list` and `block` are the two equivalent forms for collections of expressions.
list  = { "(" ~ expr* ~ ")" } // Only proper lists are supported; improper/dotted lists are not allowed.
block = { "{" ~ expr* ~ "}" }

// An `atom` is any primitive, non-recursive value. The order of rules inside
// `atom` is important: `pest` tries them in sequence. We check for more
// specific types (number, boolean) before falling back to the general `symbol`.
atom = { number | boolean | string | symbol }

// -- Primitive Atom Rules --

// `number` parses floating-point or integer values. It correctly handles negatives.
// The `@` makes it an "atomic" rule, preventing `pest` from backtracking within it,
// which is more efficient and prevents partial matches.
number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

// `boolean` matches the exact keywords.
boolean = @{ "true" | "false" }

// The `string` rule is broken down to create a richer CST (Concrete Syntax Tree).
// This allows the parser to process escape sequences with full span information,
// leading to much better error messages for invalid escapes.
// The top-level `string` rule just defines the quotes.
// It is marked as ATOMIC (`@`) to prevent the silent `WHITESPACE` rule from
// being applied inside the quotes.
string = @{ "\"" ~ inner ~ "\"" }
// `inner` contains the actual content of the string.
inner = { (str_char | escape_sequence)* }
// `str_char` is any single character that is not a quote or a backslash.
str_char = @{ !("\"" | "\\") ~ ANY }
// `escape_sequence` explicitly defines the valid escape sequences.
// TODO: The parser should produce a specific error if a `\` is followed by
// an invalid character (e.g., `\q`). The current grammar doesn't parse invalid
// escapes, which `pest` will report as a generic "expected..." error. A future
// improvement could be to allow `\\ ~ ANY` and validate it in the AST-building step.
escape_sequence = @{ "\\" ~ ("\"" | "\\" | "n" | "t") }

// `symbol` definition is carefully crafted for Sutra's needs.
// It uses helper rules for clarity and maintainability.
symbol_start = { ASCII_ALPHA | "_" | "+" | "-" | "*" | "/" | "<" | ">" | "=" | "?" | "!" }
symbol_inner = { ASCII_ALPHANUMERIC | "_" | "." | "+" | "-" | "*" | "/" | "<" | ">" | "=" | "?" | "!" }

symbol = @{
    // This is a "negative lookahead". It ensures that if the parser sees
    // "true" or "false" followed by a delimiter (whitespace, end of input, or a
    // closing bracket), it will NOT match it as a symbol. This forces it to be
    // parsed by the `boolean` rule, which is what we want.
    !(("true" | "false") ~ (WHITESPACE | EOI | ")" | "}")) ~
    // A symbol must start with a character defined in `symbol_start`...
    symbol_start ~
    // ...and can be followed by zero or more characters from `symbol_inner`.
    symbol_inner*
}

quote = { "'" ~ expr }

// -- Parameter List Rules --
param_list = { "(" ~ param_items ~ ")" }
param_items = { symbol* ~ ("..." ~ symbol)? } // Only ...rest is supported for variadics.

// Macro/function definition: (define (name ... [ ...rest ]) body)
define_form = { "(" ~ "define" ~ param_list ~ expr ~ ")" }
</file>

<file path="validate.rs">
use serde::{Serialize, Deserialize};
use crate::ast::{WithSpan, Expr, Span};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum SutraSeverity { Error, Warning, Info }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SutraDiagnostic {
    pub severity: SutraSeverity,
    pub message: String,
    pub span: Span,
    // Optionally: code, suggestion, etc.
}

pub trait SutraValidator {
    fn validate(&self, ast: &WithSpan<Expr>) -> Vec<SutraDiagnostic>;
}

/// Trivial validator for pipeline scaffolding (Sprint 2).
pub struct TrivialValidator;

impl SutraValidator for TrivialValidator {
    fn validate(&self, _ast: &WithSpan<Expr>) -> Vec<SutraDiagnostic> {
        vec![]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::{WithSpan, Expr, Span};
    #[test]
    fn trivial_validator_returns_empty_diagnostics() {
        let validator = TrivialValidator;
        let ast = WithSpan {
            value: Expr::List(vec![], Span { start: 0, end: 2 }),
            span: Span { start: 0, end: 2 },
        };
        let diagnostics = validator.validate(&ast);
        assert!(diagnostics.is_empty());
    }
}
</file>

<file path="value.rs">
use crate::path::Path;
use im::HashMap;

/// Represents a value in the Sutra engine.
///
/// # Examples
///
/// ```rust
/// use sutra::value::Value;
/// let n = Value::Number(3.14);
/// assert_eq!(n.type_name(), "Number");
/// let s = Value::String("hello".to_string());
/// assert_eq!(s.type_name(), "String");
/// let nil = Value::default();
/// assert!(nil.is_nil());
/// ```
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Nil,
    Number(f64),
    String(String),
    Bool(bool),
    List(Vec<Value>),
    Map(HashMap<String, Value>),
    Path(Path),
}

impl Value {
    /// Returns the type name of the value as a string.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::value::Value;
    /// let v = Value::Bool(true);
    /// assert_eq!(v.type_name(), "Bool");
    /// ```
    pub fn type_name(&self) -> &'static str {
        match self {
            Value::Nil => "Nil",
            Value::Number(_) => "Number",
            Value::String(_) => "String",
            Value::Bool(_) => "Bool",
            Value::List(_) => "List",
            Value::Map(_) => "Map",
            Value::Path(_) => "Path",
        }
    }

    /// Returns true if the value is Nil.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::value::Value;
    /// assert!(Value::Nil.is_nil());
    /// assert!(!Value::Number(1.0).is_nil());
    /// ```
    pub fn is_nil(&self) -> bool {
        matches!(self, Value::Nil)
    }

    /// Returns the contained number if this is a Number value.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::value::Value;
    /// let v = Value::Number(2.0);
    /// assert_eq!(v.as_number(), Some(2.0));
    /// let v2 = Value::String("nope".to_string());
    /// assert_eq!(v2.as_number(), None);
    /// ```
    pub fn as_number(&self) -> Option<f64> {
        match self {
            Value::Number(n) => Some(*n),
            _ => None,
        }
    }

    /// Returns the contained bool if this is a Bool value.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use sutra::value::Value;
    /// let v = Value::Bool(false);
    /// assert_eq!(v.as_bool(), Some(false));
    /// let v2 = Value::Nil;
    /// assert_eq!(v2.as_bool(), None);
    /// ```
    pub fn as_bool(&self) -> Option<bool> {
        match self {
            Value::Bool(b) => Some(*b),
            _ => None,
        }
    }
}

impl Default for Value {
    fn default() -> Self {
        Value::Nil
    }
}
</file>

<file path="world.rs">
use crate::path::Path;
use crate::value::Value;
use im::HashMap;
use rand::{RngCore, SeedableRng};
use rand_xoshiro::Xoshiro256StarStar;

// Using a concrete, seedable PRNG for determinism.
type SmallRng = Xoshiro256StarStar;

#[derive(Clone)]
pub struct World {
    data: Value,
    prng: SmallRng,
}

impl World {
    pub fn new() -> Self {
        Self {
            data: Value::Map(HashMap::new()),
            prng: SmallRng::from_entropy(),
        }
    }

    pub fn from_seed(seed: [u8; 32]) -> Self {
        Self {
            data: Value::Map(HashMap::new()),
            prng: SmallRng::from_seed(seed),
        }
    }

    pub fn get(&self, path: &Path) -> Option<&Value> {
        let mut current = &self.data;
        for key in &path.0 {
            if let Value::Map(map) = current {
                if let Some(value) = map.get(key.as_str()) {
                    current = value;
                } else {
                    return None;
                }
            } else {
                return None;
            }
        }
        Some(current)
    }

    pub fn set(&self, path: &Path, val: Value) -> Self {
        if path.0.is_empty() {
            return self.clone(); // Or handle as an error
        }
        let new_data = set_recursive(&self.data, &path.0, val);
        Self {
            data: new_data,
            prng: self.prng.clone(),
        }
    }

    pub fn del(&self, path: &Path) -> Self {
        if path.0.is_empty() {
            return self.clone(); // Or handle as an error
        }
        let new_data = del_recursive(&self.data, &path.0);
        Self {
            data: new_data,
            prng: self.prng.clone(),
        }
    }

    pub fn next_u32(&mut self) -> u32 {
        self.prng.next_u32()
    }
}

// Default implementation for convenience
impl Default for World {
    fn default() -> Self {
        Self::new()
    }
}

// Recursive helper for immutable `set`.
fn set_recursive(current: &Value, path_segments: &[String], val: Value) -> Value {
    let key = &path_segments[0];
    let remaining_segments = &path_segments[1..];

    let mut map = match current {
        Value::Map(m) => m.clone(),
        // If we're trying to set a value on a non-map, we start with a fresh map.
        _ => HashMap::new(),
    };

    if remaining_segments.is_empty() {
        // Base case: we've reached the end of the path, so insert the value.
        map.insert(key.clone(), val);
    } else {
        // Recursive step: get the child, or a Nil default, and recurse.
        let child = map.get(key).unwrap_or(&Value::Nil);
        let new_child = set_recursive(child, remaining_segments, val);
        map.insert(key.clone(), new_child);
    }

    Value::Map(map)
}

// Recursive helper for immutable `del`.
fn del_recursive(current: &Value, path_segments: &[String]) -> Value {
    let key = if let Some(k) = path_segments.first() {
        k
    } else {
        // Should not happen if called from `del` which checks for empty path.
        return current.clone();
    };

    let mut map = if let Value::Map(m) = current {
        m.clone()
    } else {
        // Cannot delete from a non-map value.
        return current.clone();
    };

    // Base case: If this is the last segment, remove the key and we're done.
    if path_segments.len() == 1 {
        map.remove(key);
        return Value::Map(map);
    }

    // Recursive step: If the child exists, recurse on it.
    if let Some(child) = map.get(key) {
        let new_child = del_recursive(child, &path_segments[1..]);

        // If the recursion resulted in an empty map, remove the key from the current map.
        // Otherwise, update the map with the new, modified child.
        if let Value::Map(ref m) = new_child {
            if m.is_empty() {
                map.remove(key);
            } else {
                map.insert(key.clone(), new_child);
            }
        } else {
            // If the new child is not a map (e.g., Nil), update it.
            map.insert(key.clone(), new_child);
        }
    }

    Value::Map(map)
}
</file>

</files>
