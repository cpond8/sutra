// Sutra Engine - Unified PEG-based Parser
// =======================================
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/sutra.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.

use crate::ast::{Expr, Span};
use crate::error::{SutraError, SutraErrorKind};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;

// This derive macro generates the parser implementation from our grammar file.
#[derive(Parser)]
#[grammar = "sutra.pest"]
struct SutraParser;

/// Parses a source string into a Sutra `Expr` AST.
///
/// This function is the sole public entry point to the parser.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Expr)` - A single `Expr::List` representing the entire program body.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source: &str) -> Result<Expr, SutraError> {
    // `SutraParser::parse` attempts to match the `program` rule from the grammar.
    // If it fails, it returns a `pest` error, which we map to our `SutraError`.
    let pairs = SutraParser::parse(Rule::program, source).map_err(|e| {
        // TODO: A future improvement would be to use a library like `pest_consume`
        // or write a more detailed error formatter to give even more user-friendly
        // error messages than the default `pest` provides.
        let span = match e.location {
            pest::error::InputLocation::Pos(pos) => Span {
                start: pos,
                end: pos,
            },
            pest::error::InputLocation::Span((start, end)) => Span { start, end },
        };
        SutraError {
            kind: SutraErrorKind::Parse(e.to_string()),
            span: Some(span),
        }
    })?;

    // The `program` rule is guaranteed to have one inner pair (itself) if parsing succeeds.
    let root_pair = pairs.peek().ok_or_else(|| SutraError {
        kind: SutraErrorKind::Parse(
            "Parser generated an empty tree, this should not happen.".to_string(),
        ),
        span: None,
    })?;

    // We build the AST from all expressions found inside the `program` rule.
    let ast_nodes: Result<Vec<Expr>, SutraError> = root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect();

    // The entire script is wrapped in a canonical `(do ...)` block.
    let mut final_nodes = vec![Expr::Symbol(
        "do".to_string(),
        Span { start: 0, end: 0 }, // Synthetic span
    )];
    final_nodes.extend(ast_nodes?);

    let start = 0;
    let end = source.len();
    Ok(Expr::List(final_nodes, Span { start, end }))
}

/// Recursively builds an `Expr` AST from a `pest` `Pair`.
/// This is the core transformation logic.
fn build_ast_from_pair(pair: Pair<Rule>) -> Result<Expr, SutraError> {
    // ---
    // This function was refactored to solve a series of ownership errors.
    // Key principle: Extract all needed metadata (span, rule) from the `pair`
    // *before* consuming it with `pair.into_inner()`.
    // ---
    let span = Span {
        start: pair.as_span().start(),
        end: pair.as_span().end(),
    };
    let rule = pair.as_rule();

    match rule {
        Rule::list | Rule::block => {
            let inner_exprs: Result<Vec<Expr>, SutraError> =
                pair.into_inner().map(build_ast_from_pair).collect();
            Ok(Expr::List(inner_exprs?, span))
        }
        Rule::expr | Rule::atom => match pair.into_inner().next() {
            Some(inner_pair) => build_ast_from_pair(inner_pair),
            None => Err(SutraError {
                kind: SutraErrorKind::Parse(format!(
                    "Grammar bug: rule '{:?}' had no inner content.",
                    rule
                )),
                span: Some(span),
            }),
        },
        Rule::number => {
            let num = pair.as_str().parse::<f64>().map_err(|_| SutraError {
                kind: SutraErrorKind::Parse(format!("Invalid number literal: '{}'", pair.as_str())),
                span: Some(span.clone()),
            })?;
            Ok(Expr::Number(num, span))
        }
        Rule::boolean => Ok(Expr::Bool(pair.as_str() == "true", span)),
        Rule::symbol => Ok(Expr::Symbol(pair.as_str().to_string(), span)),
        Rule::string => {
            // Try to process the inner child as before (for non-empty strings)
            let mut unescaped = String::new();
            let mut used_inner = false;
            if let Some(inner_pair) = pair.clone().into_inner().next() {
                used_inner = true;
                for content_pair in inner_pair.into_inner() {
                    match content_pair.as_rule() {
                        Rule::str_char => unescaped.push_str(content_pair.as_str()),
                        Rule::escape_sequence => {
                            let escaped_char = match content_pair.as_str().chars().nth(1) {
                                Some('n') => '\n',
                                Some('t') => '\t',
                                Some('\\') => '\\',
                                Some('"') => '"',
                                _ => {
                                    return Err(SutraError {
                                        kind: SutraErrorKind::Parse(format!(
                                            "Invalid escape sequence: {}",
                                            content_pair.as_str()
                                        )),
                                        span: Some(Span {
                                            start: content_pair.as_span().start(),
                                            end: content_pair.as_span().end(),
                                        }),
                                    });
                                }
                            };
                            unescaped.push(escaped_char);
                        }
                        _ => unreachable!("Grammar should not produce other pairs inside a string"),
                    }
                }
            }
            if !used_inner {
                // Fallback: extract the substring between the quotes
                let s = pair.as_str();
                if s.len() >= 2 {
                    unescaped = s[1..s.len() - 1].to_string();
                } else {
                    unescaped = String::new();
                }
            }
            Ok(Expr::String(unescaped, span))
        }
        Rule::program
        | Rule::EOI
        | Rule::inner
        | Rule::str_char
        | Rule::escape_sequence
        | Rule::symbol_start
        | Rule::symbol_inner
        | Rule::WHITESPACE
        | Rule::COMMENT => {
            unreachable!(
                "Structural rule '{:?}' should not be processed directly by build_ast_from_pair",
                rule
            )
        }
    }
}
