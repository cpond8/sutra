// Sutra Engine - Unified PEG-based Parser
// =======================================
//
// This module is responsible for parsing Sutra source code into a canonical
// Abstract Syntax Tree (AST). It replaces the original hand-rolled parser
// with a robust implementation based on the `pest` library.
//
// Key Responsibilities:
// 1.  **Use the Formal Grammar**: It is driven by the formal PEG grammar defined
//     in `src/sutra.pest`, which is the single source of truth for syntax.
// 2.  **Unified Syntax**: It handles both s-expression `()` and brace-block `{}`
//     syntaxes, producing the identical AST for both.
// 3.  **CST to AST Conversion**: Its primary role is to transform the Concrete
//     Syntax Tree (CST) generated by `pest` into our `Expr` AST.
// 4.  **Error Reporting**: It translates `pest`'s detailed parsing errors into
//     our project-specific `SutraError` type, preserving location information.
//!
//! # Sutra Parser: Grammar-to-AST Mapping
//!
//! | PEG Rule      | AST Node         | Notes                         |
//! |---------------|------------------|-------------------------------|
//! | program       | Vec<Expr>        | Top-level expressions; see note below |
//! | expr          | Expr             | Delegates to subrules         |
//! | list          | Expr::List       | Regular or dotted list        |
//! | dotted_list   | Expr::List       | Dot as Expr::Symbol(".")      |
//! | block         | Expr::List       | Brace blocks                  |
//! | atom          | Expr             | Number, Bool, String, Symbol  |
//! | number        | Expr::Number     |                               |
//! | boolean       | Expr::Bool       |                               |
//! | string        | Expr::String     |                               |
//! | symbol        | Expr::Symbol     |                               |
//!
//! **Span conventions:**
//! - All AST nodes carry a span covering the full source range of the parsed form.
//! - For dotted lists, the dot is represented as `Expr::Symbol(".")` with the span of the entire dotted list (not just the dot token).
//! - This is intentional for simplicity and is documented for downstream consumers.
//!
//! **Program node representation:**
//! - The public `parse` API returns a `Vec<Expr>` for top-level forms.
//! - Internally, `build_program` returns an `Expr::List` for uniformity, but this is unwrapped by `parse`.
//! - If a canonical program node is ever needed, document and update accordingly.

use crate::ast::{Expr, Span};
use crate::error::{SutraError, SutraErrorKind};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;

// This derive macro generates the parser implementation from our grammar file.
#[derive(Parser)]
#[grammar = "sutra.pest"]
struct SutraParser;

/// Parses a source string into a vector of top-level Sutra `Expr` AST nodes.
///
/// This function is the sole public entry point to the parser. It is purely
/// syntactic and does not add any semantic wrappers like `(do ...)`.
///
/// # Arguments
/// * `source` - A string slice containing the Sutra code.
///
/// # Returns
/// * `Ok(Vec<Expr>)` - A vector of expressions found at the top level of the source.
/// * `Err(SutraError)` - If parsing fails.
pub fn parse(source: &str) -> Result<Vec<Expr>, SutraError> {
    // `SutraParser::parse` attempts to match the `program` rule from the grammar.
    // If it fails, it returns a `pest` error, which we map to our `SutraError`.
    let pairs = SutraParser::parse(Rule::program, source).map_err(|e| {
        // TODO: A future improvement would be to use a library like `pest_consume`
        // or write a more detailed error formatter to give even more user-friendly
        // error messages than the default `pest` provides.
        let span = match e.location {
            pest::error::InputLocation::Pos(pos) => Span {
                start: pos,
                end: pos,
            },
            pest::error::InputLocation::Span((start, end)) => Span { start, end },
        };
        SutraError {
            kind: SutraErrorKind::Parse(e.to_string()),
            span: Some(span),
        }
    })?;

    // The `program` rule is guaranteed to have one inner pair (itself) if parsing succeeds.
    let root_pair = pairs.peek().ok_or_else(|| SutraError {
        kind: SutraErrorKind::Parse(
            "Parser generated an empty tree, this should not happen.".to_string(),
        ),
        span: None,
    })?;

    // We build the AST from all expressions found inside the `program` rule.
    root_pair
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect()
}

// Utility function for consistent span extraction
fn get_span(pair: &pest::iterators::Pair<Rule>) -> Span {
    Span { start: pair.as_span().start(), end: pair.as_span().end() }
}

// --- Refactored AST builder helpers ---

/// Recursively builds an `Expr` AST from a `pest` `Pair`.
fn build_ast_from_pair(pair: Pair<Rule>) -> Result<Expr, SutraError> {
    match pair.as_rule() {
        Rule::program => build_program(&pair),
        Rule::expr => build_expr(&pair),
        Rule::list => build_list(&pair),
        Rule::dotted_list => build_dotted_list(&pair),
        Rule::block => build_block(&pair),
        Rule::atom => build_atom(&pair),
        Rule::number => build_number(&pair),
        Rule::boolean => build_boolean(&pair),
        Rule::string => build_string(&pair),
        Rule::symbol => build_symbol(&pair),
        rule => Err(SutraError {
            kind: SutraErrorKind::InternalParse(format!(
                "Unexpected rule in AST builder: {:?} (input: '{}')",
                rule, pair.as_str()
            )),
            span: Some(get_span(&pair)),
        }),
    }
}

/// Handles the top-level program rule.
///
/// Note: Returns an `Expr::List` for internal uniformity, but the public `parse` API collects top-level forms as a `Vec<Expr>`.
/// If a canonical program node is ever needed, update this convention and document accordingly.
fn build_program(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let exprs = pair
        .clone()
        .into_inner()
        .filter(|p| p.as_rule() != Rule::EOI)
        .map(build_ast_from_pair)
        .collect::<Result<Vec<_>, _>>()?;
    Ok(Expr::List(exprs, span))
}

/// Handles expr rule (delegates to subrules).
fn build_expr(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst(format!(
            "Empty expr pair (input: '{}')",
            pair.as_str()
        )),
        span: Some(span),
    })?;
    build_ast_from_pair(sub)
}

/// Handles list rule (regular or dotted list).
fn build_list(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let mut inner = pair.clone().into_inner();
    if let Some(first) = inner.peek() {
        if first.as_rule() == Rule::dotted_list {
            // Dotted list: delegate to build_dotted_list
            return build_dotted_list(&inner.next().unwrap());
        }
    }
    // Regular list
    let items = inner.map(build_ast_from_pair).collect::<Result<Vec<_>, _>>()?;
    Ok(Expr::List(items, span))
}

/// Handles dotted_list rule, with validation for malformed shapes.
///
/// Note: The dot is always represented as `Expr::Symbol(".")` with the span of the entire dotted list.
/// Downstream code (e.g., macro parameter parsing) must check for `Symbol(".")` explicitly.
fn build_dotted_list(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let inner_pairs: Vec<_> = pair.clone().into_inner().collect();
    let mut dot_count = 0;
    let mut after_dot = false;
    let mut before_dot = 0;
    let mut after_dot_items = 0;
    for item in &inner_pairs {
        if item.as_str() == "." {
            dot_count += 1;
            after_dot = true;
            continue;
        }
        if !after_dot {
            before_dot += 1;
        } else {
            after_dot_items += 1;
        }
    }
    // Validation: only one dot, not at start or end, at least one expr after dot
    if dot_count != 1 || before_dot == 0 || after_dot_items != 1 {
        return Err(SutraError {
            kind: SutraErrorKind::Parse(format!(
                "Malformed dotted list: dot_count={}, before_dot={}, after_dot_items={}, input='{}'",
                dot_count, before_dot, after_dot_items, inner_pairs.iter().map(|p| p.as_str()).collect::<Vec<_>>().join(" ")
            )),
            span: Some(span),
        });
    }
    // Build AST: push exprs before dot, then Symbol("."), then expr after dot
    let mut items = Vec::new();
    for item in inner_pairs {
        if item.as_str() == "." {
            // Note: span for Symbol(".") is the full dotted list span (documented)
            items.push(Expr::Symbol(".".to_string(), span.clone()));
            continue;
        }
        items.push(build_ast_from_pair(item)?);
    }
    Ok(Expr::List(items, span))
}

/// Handles block rule (brace blocks).
fn build_block(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let items = pair.clone().into_inner().map(build_ast_from_pair).collect::<Result<Vec<_>, _>>()?;
    Ok(Expr::List(items, span))
}

/// Handles atom rule (delegates to subrules).
fn build_atom(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let mut inner = pair.clone().into_inner();
    let sub = inner.next().ok_or_else(|| SutraError {
        kind: SutraErrorKind::MalformedAst(format!(
            "Empty atom pair (input: '{}')",
            pair.as_str()
        )),
        span: Some(span),
    })?;
    build_ast_from_pair(sub)
}

/// Handles number rule.
fn build_number(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    let n = pair.as_str().parse().map_err(|e| SutraError {
        kind: SutraErrorKind::Parse(format!("Invalid number: {} (input: '{}')", e, pair.as_str())),
        span: Some(span.clone()),
    })?;
    Ok(Expr::Number(n, span))
}

/// Handles boolean rule.
fn build_boolean(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    Ok(Expr::Bool(pair.as_str() == "true", span))
}

/// Handles string rule.
fn build_string(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    Ok(Expr::String(unescape_string(pair.clone())?, span))
}

/// Handles symbol rule.
fn build_symbol(pair: &Pair<Rule>) -> Result<Expr, SutraError> {
    let span = get_span(pair);
    Ok(Expr::Symbol(pair.as_str().to_string(), span))
}

/// Pure helper function to unescape a string from a `pest` `Pair`.
///
/// Note: Only supports basic escapes (\n, \t, \\, \"). Unicode (\uXXXX) and hex/octal escapes are NOT supported.
/// This is sufficient for current narrative scripting, but should be extended if such escapes are needed in the future.
fn unescape_string(pair: Pair<Rule>) -> Result<String, SutraError> {
    // The `string` rule in the grammar is `@{ "\"" ~ inner ~ "\"" }`.
    // `pair.as_str()` gives us the full text, including the surrounding quotes.
    let full_str = pair.as_str();

    // We slice the string to remove the first and last characters (the quotes).
    // This is simpler and more robust than traversing the CST, even if it's
    // slightly less performant for very long strings. The correctness and
    // simplicity trade-off is worth it here.
    let inner_str = &full_str[1..full_str.len() - 1];

    // Now, we manually unescape the recognized sequences.
    let mut result = String::with_capacity(inner_str.len());
    let mut chars = inner_str.chars();
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('t') => result.push('\t'),
                Some('\\') => result.push('\\'),
                Some('"') => result.push('"'),
                // If we encounter an invalid escape, we just push the characters
                // literally. The grammar should prevent this, but this is safer.
                Some(other) => {
                    result.push('\\');
                    result.push(other);
                }
                // A dangling escape at the end of a string.
                None => result.push('\\'),
            }
        } else {
            result.push(c);
        }
    }
    Ok(result)
}
