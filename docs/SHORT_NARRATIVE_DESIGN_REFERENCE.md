# Designing a Storylet-Driven Narrative Engine – Insights from Emily Short and Others

Storylets and *quality-based narratives* are powerful design approaches for interactive storytelling. They offer flexible, modular ways to organize story content beyond the constraints of traditional branching trees. Emily Short’s extensive writings on these topics – along with related guidance from others in the interactive fiction community – provide a wealth of high-level design principles. Below is a comprehensive synthesis of these insights, which will inform the design of our new narrative game engine.

## What Are Storylets? (And Why You Want Them)

**Storylets** are *discrete chunks of narrative content* that become available or active under certain conditions (often tied to game state variables, or “qualities”) and that can in turn modify those game states once played. In Emily Short’s definition, a storylet consists of three parts: (1) a piece of content (which could be a passage of text, dialogue, cutscene, etc.), (2) a set of *prerequisites* or conditions that determine when that content is eligible to appear, and (3) *effects* on world state (qualities) that occur after the content is experienced. In Failbetter Games’ terminology, each piece of content is a storylet and each option within it is a *branch*.

Storylets are the core of **quality-based narrative (QBN)** design, a term coined by Failbetter Games (creators of *Fallen London*) to describe narrative structures organized around these state-driven snippets. In a QBN system, *qualities* (numerical or boolean variables) represent everything from character skills and resources to story progression flags. Storylets become available (“unlocked”) only when the right qualities are at the right levels, and choosing an option in a storylet can raise or lower those qualities as consequences.

**Why use storylets?** They introduce *far more flexibility* than a fixed branching storyline. Emily Short notes that she often sketches storylet-based solutions when consulting on narrative design, because storylets are “simple, atomic, robust, and recombinable” pieces of story. Unlike a strict branching tree, storylets allow the narrative to *respond to gameplay state* in a dynamic way, and they can be added or re-arranged with minimal disruption to the overall structure. This modularity is especially valuable for games intended to have long lifespans, expansions, or player-added content. A storylet-driven engine naturally supports games that last for years, include DLC, mesh with other gameplay systems, or even allow user-generated story content, since new storylets can slot into the system without “ripping out” or rewriting the existing structure.

Moreover, storylets help escape the dreaded *combinatorial explosion* of branching narratives. A purely branching story (especially a naive “time cave” structure that never recombines) requires exponentially more content for each decision and quickly becomes unsustainable. Storylets, by gating content with state checks, let designers reuse and recombine narrative pieces in multiple contexts. This both avoids exponential growth of paths and encourages an **emergent narrative** style – the player’s sequence of storylets can weave together in unique ways, often with meaningful or ironic results that weren’t explicitly scripted as a single branch. For example, Failbetter’s *Fallen London* contains many separate storylet arcs around the city, and a player may inadvertently create their own narrative by pursuing one goal (e.g. impressing a bishop) via an unrelated avenue (e.g. doing odd jobs for devils in exchange for money). The storylet system doesn’t force a linear connection between those plot threads, but it **allows the player to connect them through play**, yielding a player-driven irony or subplot that feels coherent in retrospect.

**Key benefits of storylets:**

* **Modularity and Recombination:** Each storylet is an independent piece. Standard narrative structures (linear gauntlets, branching paths, hubs and spokes, etc.) can all be constructed as collections of storylets plus some governing qualities. This modularity means you can add, remove, or rearrange storylets later without breaking the entire narrative flow. It’s even possible to extend a storylet-based game with new content post-release (as Fallen London does with its monthly “Exceptional Stories”) simply by writing new storylets that plug into existing qualities.

* **Avoiding Branching Explosion:** Because story progression is managed by qualities, you can merge narrative paths elegantly. Earlier choices can affect later outcomes via stat checks rather than requiring entirely separate written sequences. This is the *“delayed branching”* philosophy championed by Choice of Games: instead of forking the plot at every decision, record the decision in a variable (stat) and branch later when it truly impacts the story. The result is a linear sequence of scenes (chapters) that still reflect countless prior choices through variable checks, giving **the impression of a highly branched narrative without actually multiplying story nodes**. Short describes this generally as *“choosing which piece to show next”* based on state, rather than hardcoding a flowchart of every possible path.

* **Player Guidance Without Force:** Storylets strike a balance between linear and sandbox storytelling. They can present the player with **multiple context-relevant options at any given time** – in essence, multiple active story threads – without overwhelming them with the entire game’s scope. Well-designed UI can highlight which storylets are “always available” (repeatable or ongoing activities) vs. which are part of the current quest or chapter. This means players are *guided but not strictly railroaded*: they might have, say, a main plot storylet and a couple of side plot storylets available simultaneously, choosing which to pursue next. Short contrasts this with traditional branching (only one plotline to follow at a time) and completely open-world structures (overwhelming freedom with no direction) – storylets allow a **middle ground** where the game offers relevant choices from multiple story arcs the player is involved in.

* **Interlocking Systems for Rich Narrative:** A storylet system naturally foregrounds *game variables (stats)* as the connectors between content. This encourages thinking of narrative design in terms of interconnected systems. When well-designed, those systems (character stats, world states, resources, etc.) will influence each other and drive story events across what would otherwise be separate plotlines. For example, in Short’s game *Bee*, the protagonist has a **motivation** resource that gates certain study storylets and a **spelling skill** stat that must be raised to win the final Spelling Bee. She also has a **poverty** “menace” stat that, if it grows too high, *locks* some opportunities and *unlocks* hardship storylets. These variables cross-cut the narrative: a plot about practicing spelling might fail or succeed based on the motivation resource (from another subplot), or a family storyline might take a turn if poverty gets too high. In a branching script these interactions would be hard-coded at specific choice points, but in a storylet system they emerge organically from the state logic – *one story affects another through the game state*. This design leads to **richer, more dynamic stories**. (Short gives a delightful example of an X-Files-style narrative where Mulder’s choices in a werewolf investigation raise Scully’s “Exasperation” menace stat, which can later trigger an entirely separate “Mulder and Scully fight” episode if it gets too high. The player might then do a side-storylet of buying Scully a gift to reduce her exasperation before continuing – a narrative beat that *feels* earned and connected, though it was assembled from modular pieces.)

* **Longevity and Expansion:** Because storylet systems don’t require pre-defining a single grand branching structure, they are ideal for games that expect ongoing content updates or user contributions. You can always write another storylet (or a new set of them) and plug it into the existing web of qualities. If the engine is built for it, even player-created storylets or mods could coexist with the official content. This adaptability is why storylets are recommended for projects with long-term support and why Failbetter’s StoryNexus platform (which was open to user-authored content) was built around storylets. As Short puts it, storylet systems are a good bet for games meant to *“last for years”* or accommodate DLC and player mods.

In summary, storylets offer a **robust design paradigm** for interactive narrative: content is granular and conditional rather than big and rigid, and game state is the driver of narrative progression rather than an ever-splitting choose-your-own-adventure tree. Our engine will leverage these concepts to give designers (and players) more freedom.

## Classic Narrative Structures via Storylets

One might wonder how traditional branching story structures map into a storylet system. The answer: quite well, with a bit of reframing. Emily Short demonstrates that *any of the common CYOA/IF structures can be achieved with storylets* by using appropriate qualities as trackers:

* **Linear Sequence (Gauntlet):** A straight-line story (possibly with occasional fail/instant-death branches) can be done by having a progress quality that simply increments with each storylet. The next storylet’s prerequisite is `progress == N`, etc.. If the player makes a mistake, you might increment a *menace* stat instead (e.g. “danger” or “suspicion”) and offer a detour or setback storylet, but overall the content follows a single path. Short provides a Twine-style diagram of a gauntlet vs. a storylet implementation: in Twine it’s a chain of nodes, while in storylets it’s one quality gate after another (with perhaps a second quality tracking mistakes).

* **Branch and Bottleneck:** Branching paths that later reconverge at common events are a staple pattern (often used to give mid-game variability but ensure everyone sees key plot points). In storylets, you can still do this by allowing the progress quality to advance along different routes, then converge by requiring a certain progress value for the bottleneck event. The differences from earlier branches can be preserved with other quality flags. Essentially, the *bottleneck* is just a storylet with a prerequisite like `progress == 5` (meaning chapters 1-4 could have varied), and within that storylet you use other qualities (set by those earlier choices) to customize text or outcomes. *Choice of Games* titles use this pattern frequently: no matter how you navigated chapters 1–3, chapter 4 will happen, but it will check your stats to determine how that event unfolds. Short’s illustration shows that a branch-and-bottleneck in Twine is a graph merging back periodically, whereas in storylets it can be managed by a single linear quality (progress) plus conditional text for variations.

* **“Sorting Hat” Early Branching:** The “sorting hat” structure refers to an early choice (or quiz) that puts the player on one of several distinct story paths (as in being sorted into a Hogwarts house, or choosing a faction at the start). After that, each path might be largely linear. This is effectively multiple smaller narratives that share a beginning. Storylets handle this by using a *classification quality*. For instance, a “house” or “path” variable is set based on early choices, and subsequent storylets check `path == Gryffindor` (for example) vs. `path == Slytherin` to determine which content to show. Internally, it’s as if you have separate storylet sequences for each path. Because storylet systems are adept with flags, you can also have some later re-convergence or interaction between paths if desired (e.g. a storylet open to all paths but with different branches for each). Sam K. Ashwell notes that *Sorting Hat structures give a lot of replay value* but require writing essentially separate stories, so they’re a trade-off. Our engine should make it easy to set such a path flag and gate content accordingly.

* **Hub and Spoke / Open Map:** Many game narratives allow the player to do a set of subquests in any order (often returning to a hub in between). In pure branching, modeling “free order” is complex, but storylets excel at this kind of structure. If three storylets (A, B, C) can be done in any sequence, the game can simply have all three available and use qualities to mark each as done once completed. For example, a quality “Quest A completed” toggles on after doing A’s storylet, and the remaining storylets B and C just require that their own completed flags are false. Once all three are done, another storylet (the finale) unlocks, perhaps with prerequisite `A_done && B_done && C_done`. This is **much cleaner than branching**. Short points out that something as simple as letting the player gather three clues in any order is trivial in a quality-based system (just three independent storylets) but would produce a messy branching diagram if written out with every ordering (ABC, ACB, BAC, BCA, CAB, CBA). Our engine’s data structures (likely event pools keyed by conditions) will naturally handle this, whereas a linear scripting approach would struggle.

* **Looping / Cyclic Structures:** Some stories intentionally loop through similar events multiple times, either until a condition is met or with incremental changes each cycle. Failbetter’s *Fallen London* and Short’s own *Bee* use a **loop-and-grow** model: the player repeats certain cycles (days, years, seasons, etc.), but each loop things evolve slightly (skills improve, relationships progress, new options unlock). In *Bee*, the loop is yearly: each year you experience seasonal storylets (holidays, chores, etc.), then the year counter increases. This continues until the final year of the competition, at which point the narrative ends. Implementing a loop in storylets might involve a *time/loop counter quality* (e.g. `Year = 1,2,3...`) and storylets that reset or reappear each cycle. Bee tracks “month” and “year” qualities; every storylet played advances the month, and when month rolls past December, the year increments. That unlocks new yearly content or the finale when a certain year is reached. This looping structure is *extremely difficult to author in a branch-based way* (you’d effectively replicate the same nodes each loop), but a storylet system can re-serve the same content repeatedly under new conditions (e.g. `while Year < 5, show holiday events`). Many roguelikes or life sims can benefit from this; our engine should support reentrant storylet loops by design.

* **Time Cave (fully divergent) Structures:** A “time cave” is the extreme branching story that never reconnects – each choice leads to wholly new branches, leading to many endings and very short individual paths. While possible to implement with storylets (using unique identifiers or flags to ensure each piece only follows its specific predecessor), Short cautions that **time caves lose most of the benefits of storylets**. If every piece of content has a completely unique prerequisite (like a flag set by the one choice that leads there), you’re essentially duplicating the hard branches in another form. You’re no longer leveraging the reusability or combinatorial flexibility; you’re just encoding a static tree in qualities. In Short’s words, at that point *“you’re not getting most of the value of using storylets”* – you might as well be using a simpler CYOA format. Time caves quickly become “a pit into which you may throw your time and work, endlessly,” as one commentator wryly noted. Most large games wisely avoid a completely unmerged branching structure. Instead, they might include *localized* time-cave segments (short sequences of heavy branching that later fold back in). This is a good compromise: you give the player a wild divergent experience for a chapter, then use a storylet to bring all players back to a common point thereafter. If our engine needs to support these “micro time-caves,” we can – e.g. by allowing a storylet to encapsulate a brief internally branching scene – but we’ll encourage designers to merge or reuse threads afterward (as Versu did by embedding short branch segments inside a broader storylet-driven simulation).

In summary, **storylets can express all the common narrative patterns** (and more), but they do so by relying on *game state variables (qualities) rather than a hardcoded graph structure*. As a result, the narrative feels fluid: classic linear or branching sequences are just special cases of the larger storylet pool being constrained by certain conditions (like a progress counter). Our engine’s role is to provide an interface for defining these conditions and progression logic easily, so authors can think in terms of “chapter = quality threshold” or “path = flag X” instead of drawing gigantic narrative flowcharts.

### Example: Choice of Games and *Delayed Branching*

The Choice of Games (CoG) design philosophy is a practical demonstration of many of the above points. In *ChoiceScript* games, the story is organized into chapters that **always occur in a fixed order**, but player choices within those chapters update stats which then determine outcomes later. Dan Fabulich (CoG founder) explains that if you naïvely tried to write a 20-page interactive story by branching every choice, you’d need a million pages of text; CoG’s solution is to instead “aggressively merge” branches and use *numerical scores (stats) to keep track of choices*. For example, in *Choice of the Dragon*, an early choice sets a *Brutality* vs. *Finesse* stat. Later, when facing heroes, the player can choose to fight honorably or set a trap – but whether that succeeds depends on the earlier stat (a brutal dragon wins the duel but fails at stealth, a finesse-focused dragon wins with a trap). The plot doesn’t branch into two separate written scenes for this decision; it has one encounter scene with two options and conditional outcomes inside it. This is exactly the QBN philosophy: **use game state (stats) to “branch” invisibly** inside a scene, instead of hard forking the scene into two separate narrative paths.

CoG refers to this as *delayed branching*, and it’s effectively what our storylet system will do globally. Early choices “set variables” and later scenes “check variables” – a design that ensures *every choice matters* (because it changes a stat) without needing bespoke downstream content for each choice. In CoG’s experience, this method preserves interactivity while keeping the story manageable to write. They note that using flags for every single choice (i.e. remembering exact decisions rather than abstracting them to stats) becomes impossibly complex after a few hundred decisions. Using a handful of well-chosen stats is far more tractable – it compresses many micro-choices into a few dimensions like “Brutality vs Finesse” or relationship values, etc.. In our engine, we will similarly encourage authors to use *qualities as state abstractions* instead of writing binary branches for everything. It not only controls content bloat but also forces a cohesive design: the stats you choose become the *themes and conflicts* of your story (CoG advises that “the stats will embody the essential conflicts of your story” and to choose them wisely). In other words, deciding the core qualities is a top-level narrative design decision.

Finally, CoG’s metrics indicate most players do not immediately replay interactive novels to see other branches. Thus, it’s important to make the first playthrough feel complete and personalized. *Illusions of choice* can be leveraged: giving options that eventually lead to the same place can still increase agency if the player feels they expressed themselves. Our engine can support such illusions (e.g. multiple storylets funneling to one outcome) as a valid design pattern. The key is that **every choice should at least produce a stat change or flavor difference** so the player perceives an effect. If nothing at all changes, players feel cheated; if something subtle changes (a variable moves, a later line is different), the choice has meaning in the system.

## Interlocking Story Systems: Qualities, Stats, and Resources

One of Emily Short’s core insights is that designing with storylets naturally leads you to design **interlocking systems of narrative variables**. Since storylets are unlocked by qualities, you end up asking: *What variables does my story world have, and how do they interplay?* In storylet-driven games, stats are not just RPG-style combat numbers; they often directly represent narrative progress or character relationships. Some categories of qualities and their roles in narrative design include:

* **Progress Trackers (Story Progress Stats):** These are qualities that measure how far along a plot or character arc the player is. For example, “YearsPassed” in *Bee* gates the major chapters, or a “MainQuestProgress” stat might unlock the finale when it reaches a certain value. Often these are incremented at paced intervals to advance the main storyline. In *Bee*, Emily Short used *multiple progress stats* simultaneously: one for the overall years of the protagonist’s growth (the main arc), and separate counters for sub-arcs like individual family relationships. This allowed episodic content (e.g. a side story about bonding with your father) to run in parallel with the main timeline, occasionally interweaving. Our engine should let designers define any number of parallel progress counters. The concept of **waypoints** or **chapters** in the narrative can simply be implemented as numeric qualities that storylets check against.

* **Menaces (Negative Meters):** “Menace” stats represent accumulating trouble or undesirable state – in other words, *failure trackers*. In Fallen London, for example, qualities like Nightmares, Wounds, Scandal, and Suspicion act as menace meters; if they get too high, bad things happen (or special menace storylets unlock). In *Bee*, **Poverty** is a menace stat – certain choices might increase Poverty, and if it rises too much, it can lock the player out of some high-class activities while opening up hardship scenes. Menace stats create tension and **consequence over time**, beyond immediate success/fail of an action. They also encourage the player to manage risk. Our design should allow threshold triggers on menace qualities (e.g. if Suspicion > 5, unlock the “Arrested!” storylet). Such stats often work in tandem with resource stats: e.g. you might need to do a side mission to *lower* a menace (like Mulder buying a gift to reduce Scully’s Exasperation) just as you’d do missions to raise a positive stat.

* **Resources and Currencies:** These include money, inventory items, or abstract *tokens of progress* (like “3 clues gathered” or “favor with the Guild”). Resources often serve as **currencies the player can spend** to access storylets. For instance, many casual story games make the player collect stars or points by playing gameplay levels, and then spend those to unlock story scenes (as in *Lily’s Garden*, where completing match-3 levels yields stars that the player uses to open new storylets). Resources can also gate choices *within* storylets: e.g. an option “\[Pay 100 gold] Bribe the guard” is only selectable if you have ≥100 gold (and if chosen, deducts that gold). According to Tadhg Kelly’s taxonomy (as cited by Short), currencies are most fun when they have thematic flavor. So our design should not treat resources as mere numbers, but allow them to carry story context (e.g. separate currencies like *Hellfire Jade* vs *Celestial Lenses*, which NPCs value differently). Currencies give players **tangible goals** to pursue in other gameplay systems that then feed back into storylets. For example, *Fallen London* requires certain item cards or currencies to embark on specific storylets – which means the player might go do a *grind* to get that item, creating a natural gameplay-story loop. We should ensure the engine allows *spending* qualities as costs and supports conditional text based on them (e.g. “Because you have the **Royal Signet Ring**, the queen listens to you favorably”).

* **Relationship and Reputation Stats:** These are specific types of progress stats often used to measure how an NPC feels about the player, or how the player stands with a faction. They function like other qualities (unlocking special interactions at high or low values) but carry narrative weight – e.g. a high Love interest stat might trigger a romance scene, while a high Notoriety might lead to being challenged by rivals. In storylet terms, relationship stats are straightforward prerequisites (“if RomanceLevel > 50, show confession storylet”). However, Short notes something subtle: **it’s often useful to have both gradual scene-level changes and larger arc-level changes** for such stats. For example, each flirtatious action could add +1 “Attraction” (micro-level), but only finishing a whole date scene might add +10 “RomanceProgress” (macro-level). This two-layer approach (sometimes called “minor” vs “major” outcomes) avoids a single conversation swinging a relationship from hate to love in one go; it requires consistent choices over time to significantly shift the macro stat. Our engine can facilitate this by letting storylets modify multiple qualities at once (e.g. a small change to one stat and a bigger change to another). **Opposed pairs** (like friend vs enemy) are another common technique – essentially two stats that sum to a constant, representing a spectrum. Choice of Games uses this for personality traits (e.g. Ruthless vs Merciful 0–100%). Short’s discussion of narrative states confirms that 2-variable or 3-variable models are often plenty expressive for a single scene or relationship. We should thus support opposed stats or at least easy inversion checks (“if Trust > 50” vs implicitly “if Distrust < 50”).

* **Territory/Location Flags:** In some games, *where* the player is (or has been) is a key narrative factor. A **territory stat** might be as simple as a current location variable (e.g. `Location = Temple`), which gates only the storylets available in that place. Or it could be more abstract, like factions or regions unlocked. Tadhg Kelly included “territory” as one of his four types of game numbers, meaning any stat that represents *where the player can go*. In narrative terms, territory often constrains which storylets make sense. Our engine should allow location-based filtering of content easily. For instance, if the player is in *City A*, only storylets tagged for City A appear; traveling to *City B* flips a flag and now City B’s pool is shown. This is essentially how open-world narrative content is organized. Territory can also be used creatively – e.g. a psychological state could be treated like a “location” that changes available scenes (think *Silent Hill’s* Otherworld). The key is to track it as a quality and attach it to storylet prerequisites.

* **Tools / Abilities:** These are stats or flags that indicate the player’s *capabilities*, which in turn unlock new **verbs or options**. For example, if the player learns the “Lockpicking” skill, then many future storylets might offer a new “\[Pick the lock]” choice where previously there was none. In Failbetter’s games, having certain **quirks or skills** opens up special branches in stories. Tools can also be literal items that grant abilities (a magic key that opens any door, enabling alternate routes in various stories). Short notes a challenge with this design: to make an ability feel worthwhile, *content creators must provide regular opportunities to use it* thereafter. It’s disheartening to pick a cool skill and rarely see it come into play. Our engine can help by allowing broad tagging of storylets with required abilities, and perhaps by analytic tools that ensure each skill intersects with many storylets. Additionally, Short mentions *procedural solutions* to ensure tool usefulness – for instance, dynamically generating small encounters to use your rare skill if none have occurred in a while. That may be beyond our initial scope, but keeping the design open to procedural insertion is wise for future development.

* **Meta-variables (Dramatic Flags):** Not explicitly covered above, but hinted in Short’s *Narrative States* discussion, are variables representing *narrative needs*, like “Act II climax triggered.” In salience-based narrative (more on that below), one might use a variable to indicate how close the story is to a turning point, so the system can choose a storylet that escalates appropriately. We mention this because in a dynamic story engine, it may be useful to have built-in pacing or dramatic-phase variables that content can hook into (e.g. only trigger certain events after the midpoint, or only when tension is above a threshold). The concept of a *waypoint* narrative (see below) is related – where certain key events act as waypoints that the narrative will eventually hit.

In the context of our engine, we should ensure it’s easy to define and manipulate all these kinds of qualities. Designers will need to mark storylets with prerequisite expressions (e.g. `Menace < 5`, `Location == Jail`, `Skill:Lockpicking == true`, `RomanceLevel >= 60`, etc.) and outcomes (e.g. increase a stat, set a flag, give an item). The engine’s storylet scheduler should then consider all storylets and pick those whose conditions are satisfied to present to the player – or, alternately, automatically present the highest “salience” one if we’re doing an AI-driven narrative (discussed next).

## Alternative Narrative Progression Models

Emily Short’s article **“Beyond Branching: Quality-Based, Salience-Based, and Waypoint Narrative Structures”** identifies three approaches (QBN, salience, waypoint) to organizing interactive story progression. We’ve covered QBN/storylets in depth. Let’s briefly summarize the other two, as they can inform engine features beyond the standard player-chooses-from-available-storylets mode:

### Salience-Based Narrative (System-Selected Content)

A *salience-based narrative* is one where the game system dynamically picks the next piece of content based on what’s happening, rather than offering the player an explicit menu of choices. In other words, the *most contextually appropriate storylet fires automatically*. This approach is often used for ambient dialogues or reactive banter in games. For example, **Left 4 Dead** monitors gameplay conditions (like a player’s health or recent events) and triggers character dialogue lines that fit those conditions (e.g. a character will shout “I’m reloading!” because that event became salient). Similarly, **Firewatch** would play dialogue between the protagonist and Delilah based on what the player inspected or did, with the game deciding the right line based on context tags (e.g. if you just found a clue, Delilah might comment on it).

In a salience model, you typically have a large pool of content each tagged with some applicability criteria (similar to storylet prerequisites). The system continuously evaluates which piece is **most relevant** at any given moment. “Relevance” might be determined by boolean conditions (e.g. `if player_has_item_X and not heard_line_Y`) or by numerical weights (e.g. several possible lines each have a score based on current variables, and the highest score triggers). Short describes it as picking content “depending on which content element is judged to be most applicable at the moment”. It’s essentially an *AI Director* for narrative.

**Advantages:** Salience-based delivery is great for *gradually layering story into gameplay*. It allows you to start with a generic base (fallback lines for any situation) and then add more specialized reactions over time, without needing full coverage for every single scenario. Designers can keep inserting new context-specific storylets and the system will use them when appropriate, otherwise defaulting to more general ones. It’s also largely invisible to the player – it feels like the game is just naturally responding, rather than prompting the player to choose. This can preserve immersion in gameplay-heavy contexts (players aren’t constantly clicking dialogue options; instead, companions talk on their own when relevant).

**Design Challenges:** Pure salience-based progression can make it hard to ensure a satisfying narrative arc. If content is triggered purely by context matches, you risk *unintended sequencing*. For example, a system might accidentally play a climactic revelation too early just because certain conditions were coincidentally met, thus *“accidentally satisfying all the preconditions”* for that content out of order. Left 4 Dead and Firewatch avoid this by coupling the salience dialogues to an underlying linear structure – there is still an authored sequence of chapters or days, and the reactive lines fill in between scripted beats. In a more freeform game, one solution is to include the *dramatic stage* as part of the salience conditions. E.g., tag a storylet with `act3 == true` in addition to its situational triggers, so it won’t occur until the story is appropriately advanced. Our engine could support a notion of “global story phase” or allow designers to include narrative pacing variables in the prerequisites.

Short also mentions that salience matching might not always produce the best **pacing or contrast** that a human author would. A storylet that’s powerful when used as a planned climax might feel abrupt if the system serves it too soon or without sufficient buildup. To mitigate this, one could implement weighting schemes that take into account not just context relevance but also things like time elapsed, variety (don’t repeat a type of event too often), and dramatic tension curves.

For our engine, supporting salience-based narrative would mean implementing an *autonomous director mode* where the system can evaluate eligible storylets and select one rather than exposing all to the player. This could be useful for **AI-driven NPC dialogues**, background events, or even fully automated storytelling (for a more narrative toy/sim). While the core data (storylets with conditions) is the same, the logic for presentation differs. We might want a configurable setting for storylet containers: *menu-driven* (player sees options) versus *auto/director-driven* (game picks an event to play).

### Waypoint Narrative (Guided Freeform with Key Triggers)

Waypoint narrative is a term Short uses (inventing it for her article) to describe a structure where the story has certain key *trigger points* it must hit (the waypoints), but the path between them can vary and is influenced by the player. In her example, the game *Glass* is a conversational scenario where both the player and NPC can introduce topics. There are specific critical topics that advance the plot (think of them as the *checkpoints* or story beats that must happen), but the order and manner in which the conversation arrives at those topics is not strictly scripted.

**How it works in Glass:** The system knows what the next trigger topic to advance the story is. It then dynamically *pathfinds through the conversation graph* to bring that topic up, if the player doesn’t bring it up themselves. For instance, if the next required story beat is to discuss the King’s secret, the NPC might need to steer the conversation from whatever current topic to that topic. It has a graph of topic connections and finds a route: maybe from current topic “people” -> “God” -> “royalty” (where “royalty” is the trigger topic). The NPC will say a line to pivot from people to God, then (if the player doesn’t interrupt) continue from God to royalty, and thus hit the waypoint, advancing the scene.

However, the player *could* interject with a different topic change. If the player brings up something off-path, the system recalculates a new way to eventually get to the waypoint. And once a particular path has been used or a topic exhausted, the system marks it to avoid repetition (e.g. it won’t use the exact same segue twice). The waypoint approach thus creates a feeling of a free, flowing conversation that nonetheless will land on the necessary story beats one way or another. If the player does nothing special, the NPC will carry the conversation to the next plot point on its own; if the player deviates, the NPC adapts but still eventually reaches the plot point via another route.

This structure is very powerful for maintaining **narrative coherence in open interactions**. It ensures the story has a shape (the waypoints in sequence) while allowing a lot of improvisation in between. Essentially, it’s a hybrid of branching and AI-driven narrative: the high-level sequence is predetermined, but low-level moment-to-moment content is reactive.

For our engine, supporting something like waypoint narrative would involve a few features:

* The notion of *priority goals or triggers* that the system actively works toward.
* A representation of possible intermediate steps (in Glass, a conversation topic graph). In other contexts, waypoints could be physical goals (e.g. find three clues to move to next chapter, in any order – which we already handle via QBN) or plot revelations (which might need prerequisite clues).
* Dynamic adjustment if the player’s actions skip or alter the needed path. (E.g. if the player in Glass themselves brings up the final topic, the system would recognize the waypoint is reached and not redundantly try to steer there.)
* Ensuring previously used content isn’t repeated verbatim, to keep the experience fresh (the Glass example of weighting down an already-used path).

Waypoint narratives may be particularly relevant if we implement a **sophisticated dialogue engine or investigation engine**. Many detective games use a waypoint-like design: you have to uncover certain key clues (waypoints) but you might explore leads in various orders. That’s essentially the clue-gathering scenario we discussed, which QBN handles gracefully with independent storylets. Glass’s innovation was having an NPC proactively contribute to reaching the goal. In an engine context, one could imagine NPC AI that selects storylets to present to the player in order to guide them (which is a bit like salience-based but with a directed goal, not just reactive).

In summary, waypoint structures give **authorial control at the macro level** (the story will cover these events in some order) while granting **player (and NPC) agency at the micro level**. Our engine can accommodate this by mixing modes: free exploration until conditions met, then trigger next plot event, etc. It’s somewhat akin to many RPG designs (free roam until you’ve done enough, then next main quest triggers), but executed conversationally or within one scene in Glass’s case.

## Controlling Narrative Pacing and Complexity

One risk of a highly system-driven narrative is that it could become *unfocused or poorly paced*. Emily Short emphasizes the importance of pacing even in storylet systems, and she has methods for charting and adjusting pacing:

* **Mixing Open and Closed Segments:** Interactive narratives often feel best when they alternate between *open-ended segments* (where the player has lots of freedom to roam, grind, or choose activities) and *tight, scripted segments* (climactic moments, cutscenes, or linear sequences). “Areas where the player has a lot of freedom tend to feel less intense; more linear, constrained sections are good for climactic moments. Alternating the two keeps the experience from feeling too stale,” Short advises. In a storylet context, you can design some storylets or clusters to be *sandboxy* (player can do them in any order, or repeat them) and others to *fire in a strict sequence*. For example, you might allow the player to undertake several side-missions (open) but once they start the final mission, it plays out in a linear series of storylets with no distraction (closed). Our engine should allow marking sequences that, once entered, temporarily limit what else is available, thereby focusing the player. This can be done via qualities (e.g. a “inFinalMission=true” flag that hides all side quests until resolved).

* **“Pacing Chart” of Storylet Clusters:** Short sometimes sketches a high-level chart of a story arc, denoting each segment’s nature. For example, in a Bond-like spy narrative, she might outline: an intro segment (linear hook), then a *gear-up phase* (open, player can spend resources to prepare, deciding when to stop – a self-paced segment), then an infiltration segment (which might be a series of semi-random challenges – a “wheel” of encounters that could go various ways), then if things go wrong, a *menace recovery loop* (e.g. if caught, do a mini-game to escape – a procedural segment acting as a soft fail state), and finally a *climactic confrontation* that is more linear and timed, followed by an *aftermath* that quickly leads to a cliffhanger (very linear, fast-paced). By charting these, a designer ensures a rhythm: the player isn’t in an intense scripted scene all the time (exhausting, railroady), nor in completely open wandering all the time (which could become aimless). **Visualizing the flow** of storylet “modes” (open hub vs linear chain vs random wheel) is a great practice we can incorporate in design tools. We might allow designers to label storylets or arcs with tags like “exploration segment” or “finale” to keep track of pacing.

* **Resource and Time Costs as Pacing Mechanisms:** Storylet systems can use *resource requirements to slow down or speed up* the narrative appropriately. Short gives an example: at the very start of a storyline, you might gate progress behind a resource the player must gather elsewhere, *forcing them to explore or grind a bit* before continuing. This ensures the player doesn’t blaze through the main plot without engaging with side content or gameplay. Similarly, at a dramatic choice, you might let the player decide how much resource to spend to improve odds of success, which not only creates a stake-setting moment but also can pace the game (the player might pause and go prepare if they feel unready). In our engine, implementing *cost to initiate storylet* or *cost within branch choice* is important. We already plan for that with resources. It effectively lets designers put “pauses” where players must do something else (gather money, etc.) – a pacing break. Conversely, towards the end, you generally don’t want big resource barriers stopping momentum, so final sequences should have minimal gating and more payoff.

* **Reusing Systemic Content for Pacing:** If your game has a generic system (like travel between locations, or a combat mini-game), you can deploy it strategically to modulate pacing. Short mentions a “purple travel wheel” in her example: a familiar travel sequence is inserted right before the big showdown to “build anticipation and create a sense of occasion”. Because the player has seen the travel mini-game or sequence before, it’s not introducing new story beats, but it serves as a *breather and tension-builder*. However, she notes that doing this *too early* (at the start of a story) would be unsatisfying because the story hasn’t hooked the player yet – you don’t want the first scene to be a generic grind; it should be unique. Takeaway: *use familiar mechanics at mid-story or later for pacing, but always start with something novel*. We can incorporate this insight by encouraging initial storylets of arcs to be unique content, while later on it’s acceptable to lean on reusable event pools (the player by then understands them as part of the game’s fabric).

* **UI Signaling and Player Feel:** Our engine’s UI/UX can assist pacing by how it presents available storylets. Short points out that *good UI is needed to make multiple concurrent story options comfortable* for the player. We might implement visual grouping (e.g. separating “main story” vs “side events” on screen) or highlights for urgent storylets. Fallen London, for instance, lets authors mark storylets as *pinned* or *gold-framed* for crucial ones, and uses color-coding to draw attention to new or important content. Our engine should allow similar presentation cues, so that at a climax we might highlight the critical storylet in the UI, whereas during open periods the UI just shows a list of various options. This way the player *intuitively senses* when they are in a high-stakes linear segment vs a sandbox segment.

* **Player Expectations and Choice Design:** A facet of pacing is how choices are *framed*. Short’s writing (and Cassie Phillips’ GDC talk) emphasize that not all choices should be equal, and players can get choice fatigue if every moment has 5 options. Sometimes a single obvious choice or no choice (just a click to continue) is appropriate, especially in fast-paced scenes, whereas downtime scenes can offer lots of choices that mainly flavor the experience without huge consequences. It’s okay – even good – to *constrain choices at dramatic moments* (creating a sense of urgency or being trapped). Our engine should support branching density variance: some storylets might be written with multiple branches, others with none (auto-continue), and that’s fine. The content author should feel free to use one or many options as needed for effect. The GDC talk also suggests monitoring choices: if 85% of players choose A over B, perhaps B wasn’t meaningful and could be reworked. For us, providing analytics could help authors tune choices (this is a stretch goal feature, but something to consider – perhaps logs of choice selection frequencies).

* **Failure and Recovery:** Pacing includes the handling of failure states. The storylet approach to failure often uses menace stats and *soft failure loops*. Instead of an immediate “Game Over,” a high menace triggers a special storylet (e.g. you get thrown into prison) which might itself be a detour quest to escape, after which you return to the main plot (possibly with some consequences). This design keeps the player in the narrative even when they “lose,” and it creates a rhythm of tension (rising menace) and release (survived the menace scenario). We should ensure that designers can create such menace-driven subplots easily. In *Pacing Storylet Structures*, Short described a “red menace wheel” segment – essentially a mini-game the player must do if they pushed their luck too far and failed an objective, but it doesn’t completely stop the story. That’s ideal: it *punishes* the player with additional challenges (maintaining tension) yet *does not halt progression entirely*. Our system can facilitate this by linking high menace to an automatic storylet insertion (maybe via salience logic: if menace critical, auto-fire the menace storylet).

In summary, thoughtful narrative pacing in a storylet system involves planning *when to open up and when to funnel*, how to use the game’s systems (resources, repeated mechanics, travel, etc.) to manage the tempo, and how to signal the stakes to players. We will bake these considerations into our engine design documentation for authors, and possibly into tooling (like a visual story flow planner that isn’t strictly linear but shows dependencies and intensity levels).

## Designing High-Agency, High-Control Narratives (Lessons from Emily Short’s Mailbag and Others)

Beyond the structural aspects, there are broader *design philosophy* points from Emily Short and others that are pertinent:

* **“Set, Check, or Gate?”** – This is about *when to alter state and when to use it*. In interactive narrative design, one must decide if a given player action *sets a new state*, *checks an existing state*, or *gates content behind a state*. For example, if the player chooses “Lie to the prince,” do we (a) set a flag `PrinceTrust=false` (or decrement a trust stat) – i.e. record it for later, (b) immediately check their “Lying skill” or a prior choice to determine outcome (maybe only succeed if you previously learned a secret, etc.), or (c) gate the availability of that choice on some condition (perhaps you can only even attempt the lie if you have a forged document)? Often all three happen in different places: some choices simply branch based on current stats (check), some choices establish new facts (set), and some content only appears if you did X (gate). Short’s blog emphasizes understanding these techniques so that you use them intentionally. Our engine’s storylet framework inherently provides for gating (prerequisites) and setting (effects). *Checking* is handled by branch outcomes or conditional text within storylets. We should encourage authors to be clear on this: if a choice doesn’t set any variable or have a visible effect, it’s purely an immediate branch – which is fine if it adds flavor, but it might be a missed opportunity to track something. As a rule of thumb from CoG: try to have each meaningful choice affect at least one stat (even if just a flavor flag), so the choice has downstream ripple potential.

* **Transparency vs Mystery in Stats:** There’s a design decision whether to show the player the stats/qualities or hide them. Failbetter tends to show a lot of the qualities (you see your Menace levels, etc.), whereas Versu (an AI-based IF) did not directly show the complex social model to players, which sometimes led to players being unaware of dangers. Short’s thoughts: *if you reveal the state and outcome calculations (like showing a chart or percentages), players will start gaming it consciously*. That can be okay (it becomes more like a strategy-RPG vibe). If you hide it, players may be more immersed but also possibly confused by outcomes. One compromise: show some but not all. For instance, ChoiceScript games show you your stat values on a separate screen, but they don’t tell you the exact thresholds needed for each choice – players infer it. Another idea is giving *qualitative feedback* instead of numbers (“Scully is **exasperated** with Mulder” rather than ScullyExasperation=7). Our engine could allow both approaches. For a high-agency narrative, explicit stats can help players plan and feel agency (“I know if I raise my Strength to 80, I can smash through that gate”). For a more story-driven experience, hiding them might preserve surprises (“Why did ending I get? Possibly because I spent too much time with Wickham…”) – though Short’s narrative state charts show that if abrupt outcomes occur, a designer might add *in-game foreshadowing or warnings* to telegraph state shifts. Ideally, our engine lets authors toggle stat visibility, and maybe present certain important stats via UI (like a reputation bar) while keeping others under the hood.

* **Player as Co-Author:** Short wrote about “games of co-authorship,” listing works where the *player is creating story content alongside the game* (e.g. by writing letters, arranging comic panels, filling in mad-libs style text). While this is more niche, it’s worth noting: a narrative engine could allow *player input that becomes part of the narrative*. For instance, letting the player type a name or choose an adjective that then gets weaved into the storylets’ text. Even without full NLP, simple placeholders where the player’s earlier choices (like what they named the kingdom, or a custom goal they selected) are reflected later can enhance the feeling of co-authorship. Some story systems even let players compose parts of the story (e.g. *Elegy for a Dead World* has players write journal entries that become the story). For our engine, supporting *free-text input* could be complex (it demands parsing or just echoing text), but we can certainly support more structured co-authoring: for example, give players tools to arrange events or select storylets for themselves in creative mode. At minimum, we support “Mad Libs” style blanks and recalling player-written text for later display. This is optional but nice for custom personalization (like “Write your own spell” or similar mechanics).

* **Types of Choices:** Not all choices are about branching plot. Emily Short and others outline categories of choices that serve different purposes:

  * *“What do you do?” – Big decisive choices that lead to different content.* (These are classic branches.)
  * *“How do you do it?” – Choices that color the action (style or moral choices)*. These might not branch the outcome drastically but alter tone or stats (e.g. be kind vs cruel in accomplishing the same goal).
  * *“How well do you do?” – Reflecting challenge results.* E.g. succeed or fail at a task, often determined by stats or luck. The choice might be to attempt or not, or multiple ways corresponding to different stats (fight vs trick vs flee).
  * *“Why do you do it?” – Choices that establish motivation or inner thoughts.* These often don’t branch the external events at all, but provide role-playing and may set a flag for personality or future narrative callbacks. Cat Manning calls these **reflective choices**, which are important for player expression even if they don’t change the plot.
  * *“How do you feel about it afterward?” – Post-event reactions.* Also reflective, can adjust relationship or personality stats based on the player’s expressed feelings about what happened.
  * *“What resource do you expend?” – Choices of strategy or sacrifice.* E.g. which item to use, who to save (sacrificing the other), etc..
  * *“Where do you focus?” (Exploratory choices) – e.g. which clue to follow up next.* This might determine which content you see first (and possibly what you miss if time/resource is limited).

Our engine should empower all these types. Many are not about locking out content but about defining *player character and approach*. This means supporting **variables for character traits** and **remembering past actions** (for subtle later effects or dialogue callbacks). For example, if the player consistently chooses merciful options, an NPC might comment on their mercy later (that’s a payoff of “why/feel” reflective choices). The design takeaway: not every choice needs to cause a branch in the story graph; some choices can lead to the *same next storylet* but with a different game state or flavor text. We should thus ensure that within a storylet, different options can point to the *same next storylet ID* but set different flags. This is absolutely a scenario our engine should handle (ChoiceScript does it frequently: multiple choices all lead to the next common scene, but they set different stats or show different intermediate text).

* **Meaningful Consequences and Player Perception:** A choice is meaningful if the player *understands the stakes and cares about the outcome*. Achieving this is partly writing (foreshadow consequences, give context), partly design (deliver on what was signaled). Cassie Phillips warns against choices where the game ignores your input – e.g. offering to do something but then the character refuses to obey, unless that’s an intentional part of role-playing a predefined character. In other words, respect player agency for player-self characters; only subvert it for dramatic effect if it’s that kind of story. Also, avoid choices that feel different but yield identical outcomes without acknowledgement (players feel tricked if they replay and find that out). It’s fine for outcomes to reconverge, but at least acknowledge the choice *via a minor difference* (even if ultimately A and B end similarly, the game can include a line or stat change showing it noticed which route you took). Our engine can encourage this by making it easy to write *variant text based on earlier flags*. Emily Short often does this: e.g. a later storylet might have an extra paragraph “because you befriended the bishop earlier, he vouches for you” – which doesn’t change the outcome of a scene, but adds richness and reward for that earlier choice. We’ll ensure that conditional text insertion is supported (perhaps via inline conditional tags in the content).

* **Branch Count vs Depth:** Ashwell’s patterns and CoG’s advice both indicate that *branching narrative design is about balance*: giving enough divergence for personalization and replay, but not so much that the story loses focus or the author cannot maintain it. CoG explicitly says *more branches ≠ more engagement* if those branches dilute the story’s impact. Instead, branch where it truly matters or where it delivers a notably different perspective, and otherwise use state-driven variations to keep a mostly unified plot. For our engine, this means we expect many “rejoins” and parallel scenes rather than endless splits. We should test our model with extreme branching too, but best practices will likely involve designing *branch-and-bottleneck or hub structures* more than huge tree structures. We might provide templates or best-practice examples in documentation for common patterns (like “branch early to pick one of 3 paths (Sorting Hat), but then have each path loop through similar events and reconverge at the finale” etc.). Because the engine is for designers, incorporating these insights might mean offering sample *pattern scripts* or easy ways to set up, say, a hub with 3 sub-quests.

## Integrating Gameplay Mechanics with Narrative (Storylets in Hybrid Games)

Our engine is intended for narrative design, but it might be used in games that aren’t purely text-based – e.g. a story layered on top of other gameplay (RPG combat, puzzles, casual games). Emily Short’s **“Casual Games and Storylets: How to Make Game Mechanics Express Choice”** is directly relevant here. Key points include:

* **Interleaving Storylets with Gameplay Levels:** In many casual mobile games, story cutscenes appear between gameplay levels. The simplest method is a *linear alternation*: beat level 1, see story scene 1, beat level 2, see scene 2, etc.. This is easy but rigid. A more flexible approach (as in *Lily’s Garden*) is to decouple them via a *currency*: the player earns stars from levels and can spend a star to unlock the next storylet. Often, the game offers **multiple storylet options at once**, letting the player choose which narrative task to spend their stars on next (e.g. “clear the weeds” vs “trim the hedge” in whatever order). But you must complete all available tasks to finish the day’s chapter. This system gives players control over pacing – if someone isn’t in the mood for story, they can just keep playing levels and stockpiling stars, effectively *skipping story for now*. Meanwhile, story-lovers can save up stars and then binge several scenes back-to-back when they want to immerse in narrative. It’s a smart compromise that our engine should support: essentially, treat storylets as *rewards or costs* that tie into the core gameplay loop. This means our engine could expose an API for the gameplay side to check whether a storylet is unlocked (i.e. can spend currency to play it) and to trigger it. Or conversely, the storylet manager can inform the game that “Chapter 1 story is complete, now generate 3 gameplay missions before next storylet unlocks.” In a full engine, bridging narrative and gameplay state is crucial.

* **Choices Through Gameplay Outcomes:** One very interesting idea Short raises is making the *gameplay itself a choice interface*. That is, use how the player performs or what tactics they use in the core gameplay to branch the story afterward. For example, a level might have multiple outcomes (one game, *Galaxy of Heroes*, gives 1 to 3 stars based on how well you did). That star rating itself could drive narrative: maybe 3-star victory triggers a “celebration” storylet, 1-star narrow win triggers a “Pyrrhic victory” storylet, and 0-star (failure) triggers a “retreat” storylet. Many casual games also include *optional objectives* (find a hidden item, complete under X time) – whether the player did those could be recorded as narrative flags or affect character reactions. Essentially, **use metrics of success as branches**. Another example: if the game is a puzzle, track what *words* the player formed (in a word game) or what *fashion style* they chose (in a dress-up game) and later reflect that in story flavor. Short notes that *Opus Magnum*, a puzzle game, scores solutions on multiple metrics (cycles, area, cost); if it were tied to narrative, each metric could correspond to a different interpretation of the player’s approach (e.g. an efficient solution could impress a mentor character, an expensive solution might anger a patron, etc.).

* **Aesthetic/Stylistic Choices in Mechanics:** Games that allow creative input in gameplay (like designing an outfit, building a house, naming something) provide an opportunity for narrative acknowledgement. In *Super Stylist*, the player can choose any pink outfit to satisfy a request “something pink” – a narrative system could note whether they chose a glamorous vs casual pink ensemble and have the client react accordingly in dialogue. While our engine can’t analyze images, it could interface with game tags (e.g. the game could tag the chosen outfit with “elegant” and the storylet checks that to decide a reaction line). Similarly, decoration segments (as in *Matchington Manor* or *Lily’s Garden*) let players pick visual options that have no plot effect but personalize their experience. We might not need to script consequences for those (they often are purely cosmetic), but acknowledging them in text (“You chose the oak furniture; Grandma remarks that it reminds her of her youth”) can deepen immersion. The engine could thus allow storing what selection the player made and referencing it later.

* **Tracking Cumulative Behavior:** If direct translation of a single gameplay act to a narrative branch is tricky (maybe the player’s moment-to-moment choices are too granular or chaotic), Short suggests tracking **aggregate tendencies**. For example, in a level where the player pops bubbles of different colors, record which color they popped the most of by the end. That could signify a choice (even if the player wasn’t consciously making it narratively – maybe popping red vs blue bubbles corresponds to supporting one faction over another in-story). Over a series of gameplay actions, patterns can emerge that we interpret as a decision. This is a clever design: it gives players some subtextual agency. Our engine could facilitate this by allowing external gameplay code to increment counters for different playstyles, which later storylets evaluate. We’d have to design that on a per-game basis (the engine can’t inherently know what, say, “red bubble” means, but the game using the engine can map it to a narrative variable).

* **Reskinning Mechanics to Fit Narrative:** Sometimes to make gameplay actions carry narrative meaning, you need to *retheme* them. Short gives a funny example: “Pick red jewels if you think Character A should romance Character B, or blue jewels if you prefer Character C” is very contrived unless you integrate that idea into the fiction (e.g. “red jewels = symbol of love for B, blue = for C”). It might be more natural to just *reskin the choice*: instead of abstract jewels, maybe the game is about sending messages and you choose which person to send a message to (so the mechanic directly reflects the narrative branch rather than being metaphorical). The lesson is: if our engine is used in a game with existing mechanics, we should encourage developers to tie mechanics to story where possible – or if not possible, at least *contextualize* them with narrative framing so the player can draw connections. For instance, in a driving game, maybe winning a race by a lot vs barely could affect the story. If not, the story and gameplay remain parallel tracks. If yes, it feels more unified. So the engine might allow hooking into gameplay triggers easily (like a signal from the game that “player achieved goal X with Y performance” to which a narrative branch is attached).

* **Interpreting Player Creativity and Failure:** Short mentions that games rarely interpret *how* you fail. A failure is a failure in most designs, but narratively there’s a difference between a valiant near-success and a comically disastrous flop. A robust narrative engine could distinguish different failure conditions (perhaps via different menace increments or tags set when failing). For example, if a player “dies” in a diving game by hitting their head on a rock (a very dire fail) vs just bellyflopping (minor embarrassment), the storylet that handles failure could have different text or outcomes. Similarly, if a player creates an absurd tattoo in a tattoo game, the reaction should be different than if they were just slightly off the mark. This again requires the gameplay to supply some qualitative info to the narrative layer (like an error severity, or categories of failure). Our engine could allow a failure storylet to check, say, an “epicFail=true” flag versus a normal fail flag. Many games don’t bother, but adding this depth can make the world feel more responsive and the failures more memorable.

To integrate all this, our narrative engine will need strong *hooks/APIs* to the core game loop if it’s used in a hybrid game. It should be easy for the game to:

* Unlock storylets or branches based on gameplay (set quality values, etc.).
* Trigger a specific storylet at appropriate times (e.g. end of level).
* Query the engine if a narrative event is available or pending (so the game knows to surface it).
* Pass parameters or tags to the story engine (like outcome grades) for conditional logic.
* Possibly allow the storylet content to affect gameplay variables in return (e.g. winning a debate in a storylet gives a gameplay buff, or failing a storylet puzzle triggers a harder next level).

In conclusion on this point, **the best narrative engines don’t sit in isolation** – they interact with game mechanics. Storylets, with their prerequisite/effect structure, are ideal for this interplay because they essentially function as *rules*: “If game state X, then narrative Y, which causes effect Z on game state.” This is very similar to how a game’s logic might work anyway. We just have to ensure our engine is *extensible and communicative* so that it can slot into a larger game architecture.

---

## Conclusion

Designing a game engine around storylets and quality-based narrative means embracing a paradigm where **narrative content is modular, state-driven, and deeply integrated with game systems**. From Emily Short’s insights we gather that:

* **Flexibility and Modularity:** Storylets free us from the straitjacket of fixed branching trees, allowing for content that can recombine and adapt. Our engine will treat story nodes as conditional events, making it easy to add new stories, new choices, and even support long-term expansions without overhaul.

* **State is King:** Qualities (variables) underlie everything – progress, character traits, resources, world conditions. Designing the “right” set of qualities is crucial for a given game, as they become the levers of story logic. We will provide robust support for defining and manipulating these states, and tools to monitor them (even visualize state space if possible, to catch odd edge cases – like Short’s ternary plot for narrative states helped identify abrupt outcome boundaries).

* **Controlled Branching & Meaningful Choice:** We aim to enable **wide player agency** (through many choices and dynamic content) while still maintaining **authorial control** over key story arcs. Techniques like delayed branching (merging paths via stats), branch-and-bottleneck structures, and waypoint-driven scenes will all be possible and encouraged. Every choice should ideally register some effect, even if subtle, so that the narrative can respond down the line. We will support conditional text and callbacks to earlier actions liberally, to make the experience feel tailored.

* **Interconnected Systems:** Borrowing game design wisdom, our engine will make it natural to design systems that affect each other. Stats, resources, and storylets will intertwine: success in one storyline might provide an item needed in another; failure in a challenge might trigger a separate sub-story (menace management) before returning. This systemic approach yields narratives that players can engage with almost like a game – planning, optimizing, or intentionally sabotaging things to see different outcomes, if they wish.

* **Pacing and Polishing:** A storylet engine must give designers control over pacing – the ability to funnel the narrative at times or slow it down. With features like storylet prioritization, resource gating, and mode switching (free-roam vs linear sequences), we’ll ensure authors can create tension and release. The engine’s UI output should reflect narrative state in a player-friendly way (highlight urgent storylets, hide ones that don’t matter now, perhaps present “chapters” to the player even if under the hood it’s open content). And we’ll heed advice on making choices feel meaningful: providing context, differentiating outcomes (even if subtly), and never trivializing the player’s input.

* **Hybrid Integration:** Recognizing that many games combine gameplay and story, our engine will be designed to integrate with other systems. Whether it’s a level-based casual game or a combat-heavy RPG, the storylet system can serve as the narrative layer that takes input from gameplay (scores, actions, loadouts) and outputs narrative consequences or setups for the next gameplay segment. By treating gameplay events as just another kind of quality change, the engine can react to them like it would to any story-triggered stat change. This opens up a powerful design space where gameplay and story truly inform each other (e.g. *dynamic narrative difficulty* – fail too many fights, the narrative adapts to give you a break or an extra ally).

In building this engine, we draw on the rich design knowledge from Emily Short’s blog and related writings. The result should be an engine that supports **quality-driven storytelling**: robust, adaptable narratives that can branch without breaking, loop without losing progression, and give players both a sense of freedom and a meaningful story arc. As Short succinctly puts it, storylet systems encourage thinking in terms of systems and **“allow story arcs to affect one another in memorable ways.”** That is the guiding principle we will follow – creating a narrative architecture where everything connects, but no single playthrough will see it all, and yet every playthrough yields a coherent, engaging story.

**Sources:**

* Emily Short, “Storylets: You Want Them”
* Emily Short, “Storylets Play Together”
* Emily Short, “Pacing Storylet Structures”
* Emily Short, “Narrative States”
* Dan Fabulich, “By the Numbers: How to Write a Long Interactive Novel that Doesn’t Suck”
* Cassie Phillips, *GDC 2016: “All Choice, No Consequence: Efficiently Branching Narrative”* (summary by Don X)
* Sam Kabo Ashwell, “Standard Patterns in Choice-Based Games”
* Tadhg Kelly, “Four Kinds of Numbers in Games” (via Short’s analysis)
* Emily Short, “Casual Games and Storylets: How to Make Game Mechanics Express Choice”
* Emily Short, “Beyond Branching: Quality-Based, Salience-Based, and Waypoint Narrative Structures”
